// Autogenerated with StateSmith 0.18.0+34a94a5de0bf3f5f53012c58cebeef3eea5dac04. Last run: 2025-10-22 01:47:13 PM.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// DO NOT EDIT THIS FILE: Automatically generated by StateSmith

#include "SMSodaStreamPure.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
// #include "your_header_here.h"


// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SMSodaStreamPure* sm, SMSodaStreamPure_StateId desired_state);

static void ROOT_enter(SMSodaStreamPure* sm);

static void SATE_HWWATCHDOG_enter(SMSodaStreamPure* sm);

static void SATE_HWWATCHDOG_exit(SMSodaStreamPure* sm);

static void SATE_SAFETYFAIL_enter(SMSodaStreamPure* sm);

static void SATE_SAFETYFAIL_exit(SMSodaStreamPure* sm);

static void SATE_TILTED_enter(SMSodaStreamPure* sm);

static void SATE_TILTED_exit(SMSodaStreamPure* sm);

static void SATE_TILTED_do(SMSodaStreamPure* sm);

static void SATE_TILTED_event_hwwatchdog(SMSodaStreamPure* sm);

static void SATE_TILTED_event_safetyfail(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_enter(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_exit(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_event_hwwatchdog(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_enter(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_exit(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_enter(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_exit(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_do(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_enter(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_exit(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_do(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_hwwatchdog(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_safetyfail(SMSodaStreamPure* sm);

static void State_AutomaticMode_InitialState_transition(SMSodaStreamPure* sm);

static void State_AutomaticMode_ChoicePoint__transition(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_enter(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_exit(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_do(SMSodaStreamPure* sm);

static void STATE_CARBONATING_enter(SMSodaStreamPure* sm);

static void STATE_CARBONATING_exit(SMSodaStreamPure* sm);

static void STATE_CARBONATING_event_anykeypress(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_enter(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_exit(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_do(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_enter(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_exit(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_do(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_enter(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_exit(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_do(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_enter(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_exit(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_do(SMSodaStreamPure* sm);

static void STATE_FILTERING_enter(SMSodaStreamPure* sm);

static void STATE_FILTERING_exit(SMSodaStreamPure* sm);

static void STATE_FILTERING_do(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_anykeypress(SMSodaStreamPure* sm);

static void STATE_MAKEDRINKDONE_enter(SMSodaStreamPure* sm);

static void STATE_MAKEDRINKDONE_exit(SMSodaStreamPure* sm);

static void STATE_MAKEDRINKDONE_do(SMSodaStreamPure* sm);

static void STATE_POWERONSTANDBYREADY_enter(SMSodaStreamPure* sm);

static void STATE_POWERONSTANDBYREADY_exit(SMSodaStreamPure* sm);

static void STATE_AWAKE_enter(SMSodaStreamPure* sm);

static void STATE_AWAKE_exit(SMSodaStreamPure* sm);

static void STATE_AWAKE_event_carblevelshortpressed(SMSodaStreamPure* sm);

static void STATE_AWAKE_event_filterbuttonlongpressed(SMSodaStreamPure* sm);

static void STATE_AWAKE_event_primarybuttonpressed(SMSodaStreamPure* sm);

static void State_Awake_ChoicePoint__transition(SMSodaStreamPure* sm);

static void State_Awake_InitialState_transition(SMSodaStreamPure* sm);

static void STATE_READY_enter(SMSodaStreamPure* sm);

static void STATE_READY_exit(SMSodaStreamPure* sm);

static void STATE_READY_do(SMSodaStreamPure* sm);

static void STATE_READY_event_filterbuttonshortpressed(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_enter(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_exit(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_do(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_event_filterbuttonshortpressed(SMSodaStreamPure* sm);

static void STATE_SPLASH_enter(SMSodaStreamPure* sm);

static void STATE_SPLASH_exit(SMSodaStreamPure* sm);

static void STATE_SPLASH_do(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_enter(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_exit(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_do(SMSodaStreamPure* sm);

static void STATE_SETLEVEL_enter(SMSodaStreamPure* sm);

static void STATE_SETLEVEL_exit(SMSodaStreamPure* sm);

static void STATE_SETLEVEL_do(SMSodaStreamPure* sm);

static void STATE_SLEEPING_enter(SMSodaStreamPure* sm);

static void STATE_SLEEPING_exit(SMSodaStreamPure* sm);

static void STATE_SLEEPING_event_anykeypress(SMSodaStreamPure* sm);

static void STATE_RINSING_enter(SMSodaStreamPure* sm);

static void STATE_RINSING_exit(SMSodaStreamPure* sm);

static void STATE_RINSING_do(SMSodaStreamPure* sm);

static void STATE_RINSING_event_anykeypress(SMSodaStreamPure* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void SMSodaStreamPure_ctor(SMSodaStreamPure* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void SMSodaStreamPure_start(SMSodaStreamPure* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(State_AutomaticMode)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_AutomaticMode`.
            STATE_AUTOMATICMODE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            State_AutomaticMode_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void SMSodaStreamPure_dispatch_event(SMSodaStreamPure* sm, SMSodaStreamPure_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: SMSodaStreamPure
        case SMSodaStreamPure_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_HWWatchdog
        case SMSodaStreamPure_StateId_SATE_HWWATCHDOG:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_SafetyFail
        case SMSodaStreamPure_StateId_SATE_SAFETYFAIL:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_Tilted
        case SMSodaStreamPure_StateId_SATE_TILTED:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: SATE_TILTED_event_hwwatchdog(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: SATE_TILTED_event_safetyfail(sm); break;
                case SMSodaStreamPure_EventId_DO: SATE_TILTED_do(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Stat_GUIControlMode
        case SMSodaStreamPure_StateId_STAT_GUICONTROLMODE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_GuiModeWaitCommands
        case SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_BOTTLEFULLSENSOR: STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_StopWaterPump
        case SMSodaStreamPure_StateId_STATE_STOPWATERPUMP:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_STOPWATERPUMP_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_AutomaticMode
        case SMSodaStreamPure_StateId_STATE_AUTOMATICMODE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_AUTOMATICMODE_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break;
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Exit_Carbonating
        case SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_EXIT_CARBONATING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Carbonating
        case SMSodaStreamPure_StateId_STATE_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_DO: STATE_AUTOMATICMODE_do(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Carbonating_off
        case SMSodaStreamPure_StateId_SATE_CARBONATING_OFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_CARBONATING_OFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Carbonating_on
        case SMSodaStreamPure_StateId_SATE_CARBONATING_ON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_CARBONATING_ON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Start_Carbonating
        case SMSodaStreamPure_StateId_SATE_START_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_START_CARBONATING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_ExitFilteringOnly
        case SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_EXITFILTERINGONLY_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Filtering
        case SMSodaStreamPure_StateId_STATE_FILTERING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_FILTERING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_FILTERING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_MakeDrinkDone
        case SMSodaStreamPure_StateId_STATE_MAKEDRINKDONE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_MAKEDRINKDONE_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_PowerOnStandByReady
        case SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_DO: STATE_AUTOMATICMODE_do(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Awake
        case SMSodaStreamPure_StateId_STATE_AWAKE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_CARBLEVELSHORTPRESSED: STATE_AWAKE_event_carblevelshortpressed(sm); break;
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONLONGPRESSED: STATE_AWAKE_event_filterbuttonlongpressed(sm); break;
                case SMSodaStreamPure_EventId_EVENT_PRIMARYBUTTONPRESSED: STATE_AWAKE_event_primarybuttonpressed(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_DO: STATE_AUTOMATICMODE_do(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Ready
        case SMSodaStreamPure_StateId_STATE_READY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONSHORTPRESSED: STATE_READY_event_filterbuttonshortpressed(sm); break;
                case SMSodaStreamPure_EventId_DO: STATE_READY_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBLEVELSHORTPRESSED: STATE_AWAKE_event_carblevelshortpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONLONGPRESSED: STATE_AWAKE_event_filterbuttonlongpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_PRIMARYBUTTONPRESSED: STATE_AWAKE_event_primarybuttonpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_ReadyRinseRequired
        case SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONSHORTPRESSED: STATE_READYRINSEREQUIRED_event_filterbuttonshortpressed(sm); break;
                case SMSodaStreamPure_EventId_DO: STATE_READYRINSEREQUIRED_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBLEVELSHORTPRESSED: STATE_AWAKE_event_carblevelshortpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONLONGPRESSED: STATE_AWAKE_event_filterbuttonlongpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_PRIMARYBUTTONPRESSED: STATE_AWAKE_event_primarybuttonpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Splash
        case SMSodaStreamPure_StateId_STATE_SPLASH:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_SPLASH_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBLEVELSHORTPRESSED: STATE_AWAKE_event_carblevelshortpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_FILTERBUTTONLONGPRESSED: STATE_AWAKE_event_filterbuttonlongpressed(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_PRIMARYBUTTONPRESSED: STATE_AWAKE_event_primarybuttonpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_PowerOnInit
        case SMSodaStreamPure_StateId_STATE_POWERONINIT:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_POWERONINIT_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_SetLevel
        case SMSodaStreamPure_StateId_STATE_SETLEVEL:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_SETLEVEL_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Sleeping
        case SMSodaStreamPure_StateId_STATE_SLEEPING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_SLEEPING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_DO: STATE_AUTOMATICMODE_do(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Rinsing
        case SMSodaStreamPure_StateId_STATE_RINSING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_RINSING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_RINSING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SMSodaStreamPure* sm, SMSodaStreamPure_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case SMSodaStreamPure_StateId_SATE_HWWATCHDOG: SATE_HWWATCHDOG_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_SAFETYFAIL: SATE_SAFETYFAIL_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_TILTED: SATE_TILTED_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STAT_GUICONTROLMODE: STAT_GUICONTROLMODE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS: STATE_GUIMODEWAITCOMMANDS_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_STOPWATERPUMP: STATE_STOPWATERPUMP_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_AUTOMATICMODE: STATE_AUTOMATICMODE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING: SATE_EXIT_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_CARBONATING: STATE_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_CARBONATING_OFF: SATE_CARBONATING_OFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_CARBONATING_ON: SATE_CARBONATING_ON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_START_CARBONATING: SATE_START_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY: STATE_EXITFILTERINGONLY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_FILTERING: STATE_FILTERING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_MAKEDRINKDONE: STATE_MAKEDRINKDONE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY: STATE_POWERONSTANDBYREADY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_AWAKE: STATE_AWAKE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_READY: STATE_READY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED: STATE_READYRINSEREQUIRED_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_SPLASH: STATE_SPLASH_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_POWERONINIT: STATE_POWERONINIT_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_SETLEVEL: STATE_SETLEVEL_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_SLEEPING: STATE_SLEEPING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_RINSING: STATE_RINSING_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_HWWATCHDOG
////////////////////////////////////////////////////////////////////////////////

static void SATE_HWWATCHDOG_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_HWWATCHDOG;
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_HWWatchdog
}

static void SATE_HWWATCHDOG_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_SAFETYFAIL
////////////////////////////////////////////////////////////////////////////////

static void SATE_SAFETYFAIL_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_SAFETYFAIL;
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_SafetyFail
}

static void SATE_SAFETYFAIL_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_TILTED
////////////////////////////////////////////////////////////////////////////////

static void SATE_TILTED_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_TILTED;
    
    // Sate_Tilted behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_Tilted
}

static void SATE_TILTED_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void SATE_TILTED_do(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: do [! Tilted()] TransitionTo(State_Awake)
    if (! Tilted())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_AUTOMATICMODE_enter(sm);
        STATE_POWERONSTANDBYREADY_enter(sm);
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}

static void SATE_TILTED_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}

static void SATE_TILTED_event_safetyfail(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: Event_SafetyFail TransitionTo(Sate_SafetyFail)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_SafetyFail`.
        SATE_SAFETYFAIL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STAT_GUICONTROLMODE
////////////////////////////////////////////////////////////////////////////////

static void STAT_GUICONTROLMODE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STAT_GUICONTROLMODE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode behavior
    // uml: Event_Exit_GUI_Controlled_Mode TransitionTo(State_AutomaticMode)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_AutomaticMode`.
        STATE_AUTOMATICMODE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_AutomaticMode_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for Stat_GUIControlMode
    
    // No ancestor handles this event.
}

static void STAT_GUICONTROLMODE_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Stat_GUIControlMode
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_GUIMODEWAITCOMMANDS
////////////////////////////////////////////////////////////////////////////////

static void STATE_GUIMODEWAITCOMMANDS_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS;
}

static void STATE_GUIMODEWAITCOMMANDS_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_BottleFullSensor TransitionTo(Stat_GUIControlMode.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Stat_GUIControlMode.<ChoicePoint>()`.
        // Stat_GUIControlMode.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Stat_GUIControlMode.<ChoicePoint>() behavior
        // uml: [pumpStopsOnSensor] TransitionTo(State_StopWaterPump)
        if (sm->vars.pumpStopsOnSensor)
        {
            // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_StopWaterPump`.
            STATE_STOPWATERPUMP_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Stat_GUIControlMode.<ChoicePoint>()
        
        // Stat_GUIControlMode.<ChoicePoint>() behavior
        // uml: else TransitionTo(State_GuiModeWaitCommands)
        {
            // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
            STATE_GUIMODEWAITCOMMANDS_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Stat_GUIControlMode.<ChoicePoint>()
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_STOPWATERPUMP
////////////////////////////////////////////////////////////////////////////////

static void STATE_STOPWATERPUMP_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_STOPWATERPUMP;
    
    // State_StopWaterPump behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_StopWaterPump
    
    // State_StopWaterPump behavior
    // uml: enter / { SendDonePumpOK(); }
    {
        // Step 1: execute action `SendDonePumpOK();`
        SendDonePumpOK();
    } // end of behavior for State_StopWaterPump
    
    // State_StopWaterPump behavior
    // uml: enter / { pumpStopsOnSensor = false; }
    {
        // Step 1: execute action `pumpStopsOnSensor = false;`
        sm->vars.pumpStopsOnSensor = false;
    } // end of behavior for State_StopWaterPump
}

static void STATE_STOPWATERPUMP_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_STOPWATERPUMP_do(SMSodaStreamPure* sm)
{
    // State_StopWaterPump behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_STOPWATERPUMP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_StopWaterPump
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_AUTOMATICMODE
////////////////////////////////////////////////////////////////////////////////

static void STATE_AUTOMATICMODE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_AUTOMATICMODE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void STATE_AUTOMATICMODE_do(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: do [Tilted()] TransitionTo(Sate_Tilted)
    if (Tilted())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Tilted`.
        SATE_TILTED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_Enter_GUI_Controlled_Mode TransitionTo(Stat_GUIControlMode)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Stat_GUIControlMode`.
        STAT_GUICONTROLMODE_enter(sm);
        
        // Stat_GUIControlMode.<InitialState> behavior
        // uml: TransitionTo(State_GuiModeWaitCommands)
        {
            // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
            STATE_GUIMODEWAITCOMMANDS_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Stat_GUIControlMode.<InitialState>
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_safetyfail(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_SafetyFail TransitionTo(Sate_SafetyFail)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_SafetyFail`.
        SATE_SAFETYFAIL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void State_AutomaticMode_InitialState_transition(SMSodaStreamPure* sm)
{
    // State_AutomaticMode.<InitialState> behavior
    // uml: TransitionTo(State_PowerOnStandByReady)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_PowerOnStandByReady`.
        STATE_POWERONSTANDBYREADY_enter(sm);
        
        // State_PowerOnStandByReady.<InitialState> behavior
        // uml: TransitionTo(State_PowerOnInit)
        {
            // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_PowerOnInit`.
            STATE_POWERONINIT_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_PowerOnStandByReady.<InitialState>
    } // end of behavior for State_AutomaticMode.<InitialState>
}

static void State_AutomaticMode_ChoicePoint__transition(SMSodaStreamPure* sm)
{
    // State_AutomaticMode.<ChoicePoint>() behavior
    // uml: [CarbonationEnabled()] TransitionTo(State_Carbonating)
    if (CarbonationEnabled())
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Carbonating`.
        STATE_CARBONATING_enter(sm);
        
        // State_Carbonating.<InitialState> behavior
        // uml: TransitionTo(Sate_Start_Carbonating)
        {
            // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Sate_Start_Carbonating`.
            SATE_START_CARBONATING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_Carbonating.<InitialState>
    } // end of behavior for State_AutomaticMode.<ChoicePoint>()
    
    // State_AutomaticMode.<ChoicePoint>() behavior
    // uml: else TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode.<ChoicePoint>()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_EXIT_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void SATE_EXIT_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING;
    
    // Sate_Exit_Carbonating behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_Exit_Carbonating
    
    // Sate_Exit_Carbonating behavior
    // uml: enter / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for Sate_Exit_Carbonating
}

static void SATE_EXIT_CARBONATING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void SATE_EXIT_CARBONATING_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // Sate_Exit_Carbonating behavior
    // uml: do TransitionTo(State_MakeDrinkDone)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        SATE_EXIT_CARBONATING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_MakeDrinkDone`.
        STATE_MAKEDRINKDONE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Exit_Carbonating
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void STATE_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void STATE_CARBONATING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_CARBONATING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Carbonating behavior
    // uml: Event_AnyKeyPress TransitionTo(Sate_Exit_Carbonating)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Exit_Carbonating`.
        SATE_EXIT_CARBONATING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Carbonating
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_CARBONATING_OFF
////////////////////////////////////////////////////////////////////////////////

static void SATE_CARBONATING_OFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_CARBONATING_OFF;
    
    // Sate_Carbonating_off behavior
    // uml: enter / { StartCarbStageTimer(); }
    {
        // Step 1: execute action `StartCarbStageTimer();`
        StartCarbStageTimer();
    } // end of behavior for Sate_Carbonating_off
    
    // Sate_Carbonating_off behavior
    // uml: enter / { SolenoidPump(0); }
    {
        // Step 1: execute action `SolenoidPump(0);`
        SolenoidPump(0);
    } // end of behavior for Sate_Carbonating_off
}

static void SATE_CARBONATING_OFF_exit(SMSodaStreamPure* sm)
{
    // Sate_Carbonating_off behavior
    // uml: exit / { carbCycle++; }
    {
        // Step 1: execute action `carbCycle++;`
        sm->vars.carbCycle++;
    } // end of behavior for Sate_Carbonating_off
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_CARBONATING_OFF_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // Sate_Carbonating_off behavior
    // uml: do [CarbonationOffCycleExpired(carbCycle)] TransitionTo(State_Carbonating.<ChoicePoint>())
    if (CarbonationOffCycleExpired(sm->vars.carbCycle))
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_CARBONATING_OFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Carbonating.<ChoicePoint>()`.
        // State_Carbonating.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // State_Carbonating.<ChoicePoint>() behavior
        // uml: [IsCarbonationLastCycle(carbCycle)] TransitionTo(Sate_Exit_Carbonating)
        if (IsCarbonationLastCycle(sm->vars.carbCycle))
        {
            // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
            exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Sate_Exit_Carbonating`.
            SATE_EXIT_CARBONATING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_Carbonating.<ChoicePoint>()
        
        // State_Carbonating.<ChoicePoint>() behavior
        // uml: else TransitionTo(Sate_Carbonating_on)
        {
            // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Sate_Carbonating_on`.
            SATE_CARBONATING_ON_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_Carbonating.<ChoicePoint>()
    } // end of behavior for Sate_Carbonating_off
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_CARBONATING_ON
////////////////////////////////////////////////////////////////////////////////

static void SATE_CARBONATING_ON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_CARBONATING_ON;
    
    // Sate_Carbonating_on behavior
    // uml: enter / { StartCarbStageTimer(); }
    {
        // Step 1: execute action `StartCarbStageTimer();`
        StartCarbStageTimer();
    } // end of behavior for Sate_Carbonating_on
    
    // Sate_Carbonating_on behavior
    // uml: enter / { SolenoidPump(1); }
    {
        // Step 1: execute action `SolenoidPump(1);`
        SolenoidPump(1);
    } // end of behavior for Sate_Carbonating_on
}

static void SATE_CARBONATING_ON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_CARBONATING_ON_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // Sate_Carbonating_on behavior
    // uml: do [CarbonationOnCycleExpired(carbCycle)] TransitionTo(Sate_Carbonating_off)
    if (CarbonationOnCycleExpired(sm->vars.carbCycle))
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_CARBONATING_ON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Carbonating_off`.
        SATE_CARBONATING_OFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Carbonating_on
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_START_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void SATE_START_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_START_CARBONATING;
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { StartCarbonationLedSequance(); }
    {
        // Step 1: execute action `StartCarbonationLedSequance();`
        StartCarbonationLedSequance();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { StartCarbonation(); }
    {
        // Step 1: execute action `StartCarbonation();`
        StartCarbonation();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { carbCycle = 0; }
    {
        // Step 1: execute action `carbCycle = 0;`
        sm->vars.carbCycle = 0;
    } // end of behavior for Sate_Start_Carbonating
}

static void SATE_START_CARBONATING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_START_CARBONATING_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // Sate_Start_Carbonating behavior
    // uml: do TransitionTo(Sate_Carbonating_on)
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_START_CARBONATING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Carbonating_on`.
        SATE_CARBONATING_ON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Start_Carbonating
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_EXITFILTERINGONLY
////////////////////////////////////////////////////////////////////////////////

static void STATE_EXITFILTERINGONLY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY;
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for State_ExitFilteringOnly
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_ExitFilteringOnly
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_ExitFilteringOnly
}

static void STATE_EXITFILTERINGONLY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_EXITFILTERINGONLY_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_ExitFilteringOnly behavior
    // uml: do TransitionTo(State_MakeDrinkDone)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_EXITFILTERINGONLY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_MakeDrinkDone`.
        STATE_MAKEDRINKDONE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_ExitFilteringOnly
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_FILTERING
////////////////////////////////////////////////////////////////////////////////

static void STATE_FILTERING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_FILTERING;
    
    // State_Filtering behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { LedsSequence(LEDS_StartMakeDring); }
    {
        // Step 1: execute action `LedsSequence(LEDS_StartMakeDring);`
        LedsSequence(LEDS_StartMakeDring);
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartWaterFilterLedSequence(); }
    {
        // Step 1: execute action `StartWaterFilterLedSequence();`
        StartWaterFilterLedSequence();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartUVLEd(); }
    {
        // Step 1: execute action `StartUVLEd();`
        StartUVLEd();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { pumpStopsOnSensor = true; }
    {
        // Step 1: execute action `pumpStopsOnSensor = true;`
        sm->vars.pumpStopsOnSensor = true;
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartWaterPumpingTimer(); }
    {
        // Step 1: execute action `StartWaterPumpingTimer();`
        StartWaterPumpingTimer();
    } // end of behavior for State_Filtering
}

static void STATE_FILTERING_exit(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: exit / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: exit / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_Filtering
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_FILTERING_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_Filtering behavior
    // uml: do [WaterPumpTimerExpired()] TransitionTo(State_ExitFilteringOnly)
    if (WaterPumpTimerExpired())
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: do [IsBottleFull()] TransitionTo(State_AutomaticMode.<ChoicePoint>())
    if (IsBottleFull())
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_AutomaticMode.<ChoicePoint>()`.
        // State_AutomaticMode.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        State_AutomaticMode_ChoicePoint__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Filtering
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}

static void STATE_FILTERING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_AnyKeyPress TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_MAKEDRINKDONE
////////////////////////////////////////////////////////////////////////////////

static void STATE_MAKEDRINKDONE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_MAKEDRINKDONE;
    
    // State_MakeDrinkDone behavior
    // uml: enter / { LedsSequence(LEDS_DoneMakeDring); }
    {
        // Step 1: execute action `LedsSequence(LEDS_DoneMakeDring);`
        LedsSequence(LEDS_DoneMakeDring);
    } // end of behavior for State_MakeDrinkDone
}

static void STATE_MAKEDRINKDONE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_MAKEDRINKDONE_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_MakeDrinkDone behavior
    // uml: do TransitionTo(State_Awake)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_MAKEDRINKDONE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_POWERONSTANDBYREADY_enter(sm);
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_MakeDrinkDone
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_POWERONSTANDBYREADY
////////////////////////////////////////////////////////////////////////////////

static void STATE_POWERONSTANDBYREADY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY;
}

static void STATE_POWERONSTANDBYREADY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_AWAKE
////////////////////////////////////////////////////////////////////////////////

static void STATE_AWAKE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AWAKE;
}

static void STATE_AWAKE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY;
}

static void STATE_AWAKE_event_carblevelshortpressed(SMSodaStreamPure* sm)
{
    // State_Awake behavior
    // uml: Event_CarbLevelShortPressed TransitionTo(State_SetLevel)
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_SetLevel`.
        STATE_SETLEVEL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Awake
    
    // No ancestor handles this event.
}

static void STATE_AWAKE_event_filterbuttonlongpressed(SMSodaStreamPure* sm)
{
    // State_Awake behavior
    // uml: Event_FilterButtonLongPressed TransitionTo(State_Rinsing)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Rinsing`.
        STATE_RINSING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Awake
    
    // No ancestor handles this event.
}

static void STATE_AWAKE_event_primarybuttonpressed(SMSodaStreamPure* sm)
{
    // State_Awake behavior
    // uml: Event_PrimaryButtonPressed TransitionTo(State_AutomaticMode.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_AutomaticMode.<ChoicePoint>()`.
        // State_AutomaticMode.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // State_AutomaticMode.<ChoicePoint>() behavior
        // uml: [IsBottleFull()] TransitionTo(State_AutomaticMode.<ChoicePoint>())
        if (IsBottleFull())
        {
            // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_AutomaticMode.<ChoicePoint>()`.
            // State_AutomaticMode.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            State_AutomaticMode_ChoicePoint__transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for State_AutomaticMode.<ChoicePoint>()
        
        // State_AutomaticMode.<ChoicePoint>() behavior
        // uml: else TransitionTo(State_Filtering)
        {
            // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_Filtering`.
            STATE_FILTERING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_AutomaticMode.<ChoicePoint>()
    } // end of behavior for State_Awake
    
    // No ancestor handles this event.
}

static void State_Awake_ChoicePoint__transition(SMSodaStreamPure* sm)
{
    // State_Awake.<ChoicePoint>() behavior
    // uml: [IsFirstPowerON() || FilterLifeTimeExpired()] TransitionTo(State_ReadyRinseRequired)
    if (IsFirstPowerON() || FilterLifeTimeExpired())
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ReadyRinseRequired`.
        STATE_READYRINSEREQUIRED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Awake.<ChoicePoint>()
    
    // State_Awake.<ChoicePoint>() behavior
    // uml: else TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Awake.<ChoicePoint>()
}

static void State_Awake_InitialState_transition(SMSodaStreamPure* sm)
{
    // State_Awake.<InitialState> behavior
    // uml: TransitionTo(State_Splash)
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Splash`.
        STATE_SPLASH_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Awake.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_READY
////////////////////////////////////////////////////////////////////////////////

static void STATE_READY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_READY;
    
    // State_Ready behavior
    // uml: enter / { StartReadyTimer(); }
    {
        // Step 1: execute action `StartReadyTimer();`
        StartReadyTimer();
    } // end of behavior for State_Ready
}

static void STATE_READY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AWAKE;
}

static void STATE_READY_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_Ready behavior
    // uml: do [ReadyTimerExpired()] TransitionTo(State_Sleeping)
    if (ReadyTimerExpired())
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Sleeping`.
        STATE_SLEEPING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Ready
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}

static void STATE_READY_event_filterbuttonshortpressed(SMSodaStreamPure* sm)
{
    // State_Ready behavior
    // uml: Event_FilterButtonShortPressed TransitionTo(State_Awake.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition).
        STATE_READY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake.<ChoicePoint>()`.
        // State_Awake.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_ChoicePoint__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Ready
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_READYRINSEREQUIRED
////////////////////////////////////////////////////////////////////////////////

static void STATE_READYRINSEREQUIRED_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED;
    
    // State_ReadyRinseRequired behavior
    // uml: enter / { LedsSequence(LEDS_FilterState); }
    {
        // Step 1: execute action `LedsSequence(LEDS_FilterState);`
        LedsSequence(LEDS_FilterState);
    } // end of behavior for State_ReadyRinseRequired
    
    // State_ReadyRinseRequired behavior
    // uml: enter / { StartReadyTimer(); }
    {
        // Step 1: execute action `StartReadyTimer();`
        StartReadyTimer();
    } // end of behavior for State_ReadyRinseRequired
}

static void STATE_READYRINSEREQUIRED_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AWAKE;
}

static void STATE_READYRINSEREQUIRED_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_ReadyRinseRequired behavior
    // uml: do [ReadyTimerExpired()] TransitionTo(State_Sleeping)
    if (ReadyTimerExpired())
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Sleeping`.
        STATE_SLEEPING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_ReadyRinseRequired
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}

static void STATE_READYRINSEREQUIRED_event_filterbuttonshortpressed(SMSodaStreamPure* sm)
{
    // State_ReadyRinseRequired behavior
    // uml: Event_FilterButtonShortPressed TransitionTo(State_Awake.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition).
        STATE_READYRINSEREQUIRED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake.<ChoicePoint>()`.
        // State_Awake.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_ChoicePoint__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_ReadyRinseRequired
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_SPLASH
////////////////////////////////////////////////////////////////////////////////

static void STATE_SPLASH_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_SPLASH;
    
    // State_Splash behavior
    // uml: enter / { LedsSequence(LEDS_Splash); }
    {
        // Step 1: execute action `LedsSequence(LEDS_Splash);`
        LedsSequence(LEDS_Splash);
    } // end of behavior for State_Splash
    
    // State_Splash behavior
    // uml: enter / { ButtonsFunction(true); }
    {
        // Step 1: execute action `ButtonsFunction(true);`
        ButtonsFunction(true);
    } // end of behavior for State_Splash
}

static void STATE_SPLASH_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AWAKE;
}

static void STATE_SPLASH_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_Splash behavior
    // uml: do TransitionTo(State_Awake.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `State_Awake` state (Least Common Ancestor for transition).
        STATE_SPLASH_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake.<ChoicePoint>()`.
        // State_Awake.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_ChoicePoint__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Splash
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_POWERONINIT
////////////////////////////////////////////////////////////////////////////////

static void STATE_POWERONINIT_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONINIT;
    
    // State_PowerOnInit behavior
    // uml: enter / { LedsOff(LEDS_all); }
    {
        // Step 1: execute action `LedsOff(LEDS_all);`
        LedsOff(LEDS_all);
    } // end of behavior for State_PowerOnInit
}

static void STATE_POWERONINIT_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY;
}

static void STATE_POWERONINIT_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_PowerOnInit behavior
    // uml: do TransitionTo(State_Awake)
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        STATE_POWERONINIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_PowerOnInit
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_SETLEVEL
////////////////////////////////////////////////////////////////////////////////

static void STATE_SETLEVEL_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_SETLEVEL;
    
    // State_SetLevel behavior
    // uml: enter / { SetLevelLeds(); }
    {
        // Step 1: execute action `SetLevelLeds();`
        SetLevelLeds();
    } // end of behavior for State_SetLevel
}

static void STATE_SETLEVEL_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY;
}

static void STATE_SETLEVEL_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_SetLevel behavior
    // uml: do TransitionTo(State_Awake)
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        STATE_SETLEVEL_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_SetLevel
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_SLEEPING
////////////////////////////////////////////////////////////////////////////////

static void STATE_SLEEPING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_SLEEPING;
    
    // State_Sleeping behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for State_Sleeping
    
    // State_Sleeping behavior
    // uml: enter / { FadeOutLeds(LEDS_all); }
    {
        // Step 1: execute action `FadeOutLeds(LEDS_all);`
        FadeOutLeds(LEDS_all);
    } // end of behavior for State_Sleeping
}

static void STATE_SLEEPING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONSTANDBYREADY;
}

static void STATE_SLEEPING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Sleeping behavior
    // uml: Event_AnyKeyPress TransitionTo(State_Awake)
    {
        // Step 1: Exit states until we reach `State_PowerOnStandByReady` state (Least Common Ancestor for transition).
        STATE_SLEEPING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Sleeping
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_RINSING
////////////////////////////////////////////////////////////////////////////////

static void STATE_RINSING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_RINSING;
    
    // State_Rinsing behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { LedsSequence(LEDS_Rinsing); }
    {
        // Step 1: execute action `LedsSequence(LEDS_Rinsing);`
        LedsSequence(LEDS_Rinsing);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { pumpStopsOnSensor = true; }
    {
        // Step 1: execute action `pumpStopsOnSensor = true;`
        sm->vars.pumpStopsOnSensor = true;
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { ResetFilterLifetimeTimer(); }
    {
        // Step 1: execute action `ResetFilterLifetimeTimer();`
        ResetFilterLifetimeTimer();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartWaterPumpingTimer(); }
    {
        // Step 1: execute action `StartWaterPumpingTimer();`
        StartWaterPumpingTimer();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartUVLEd(); }
    {
        // Step 1: execute action `StartUVLEd();`
        StartUVLEd();
    } // end of behavior for State_Rinsing
}

static void STATE_RINSING_exit(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: exit / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: exit / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_Rinsing
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_RINSING_do(SMSodaStreamPure* sm)
{
    bool consume_event = false;
    
    // State_Rinsing behavior
    // uml: do [IsBottleFull()||WaterPumpTimerExpired()] TransitionTo(State_Awake)
    if (IsBottleFull()||WaterPumpTimerExpired())
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_RINSING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_POWERONSTANDBYREADY_enter(sm);
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Rinsing
    
    // Check if event has been consumed before calling ancestor handler.
    if (!consume_event)
    {
        STATE_AUTOMATICMODE_do(sm);
    }
}

static void STATE_RINSING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: Event_AnyKeyPress TransitionTo(State_Awake)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_RINSING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Awake`.
        STATE_POWERONSTANDBYREADY_enter(sm);
        STATE_AWAKE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Awake_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_Rinsing
    
    // No ancestor handles this event.
}
