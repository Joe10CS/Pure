// Autogenerated with StateSmith 0.17.2+a7141c241054b3177bab267557ecb45a8dcedd67.
// Algorithm: Balanced2. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// DO NOT EDIT THIS FILE: Automatically generated by StateSmith

#include "SMSodaStreamPure.h"
#include <stdbool.h> // required for `consume_event` flag
#include <string.h> // for memset
// #include "your_header_here.h"


// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SMSodaStreamPure* sm, SMSodaStreamPure_StateId desired_state);

static void ROOT_enter(SMSodaStreamPure* sm);

static void SATE_HWWATCHDOG_enter(SMSodaStreamPure* sm);

static void SATE_HWWATCHDOG_exit(SMSodaStreamPure* sm);

static void SATE_SAFETYFAIL_enter(SMSodaStreamPure* sm);

static void SATE_SAFETYFAIL_exit(SMSodaStreamPure* sm);

static void SATE_TILTED_enter(SMSodaStreamPure* sm);

static void SATE_TILTED_exit(SMSodaStreamPure* sm);

static void SATE_TILTED_event_hwwatchdog(SMSodaStreamPure* sm);

static void SATE_TILTED_event_nottilted(SMSodaStreamPure* sm);

static void SATE_TILTED_event_safetyfail(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_enter(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_exit(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_event_hwwatchdog(SMSodaStreamPure* sm);

static void STAT_GUICONTROLMODE_event_safetyfail(SMSodaStreamPure* sm);

static void Stat_GUIControlMode_InitialState_transition(SMSodaStreamPure* sm);

static void STATE_CARBOFF_enter(SMSodaStreamPure* sm);

static void STATE_CARBOFF_exit(SMSodaStreamPure* sm);

static void STATE_CARBOFF_do(SMSodaStreamPure* sm);

static void STATE_CARBON_enter(SMSodaStreamPure* sm);

static void STATE_CARBON_exit(SMSodaStreamPure* sm);

static void STATE_CARBON_do(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_enter(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_exit(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_carboff(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_carbon(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweroff(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweron(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_stop(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_uvledoff(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_uvledon(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_warepumpon(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_waterpumoonnosensor(SMSodaStreamPure* sm);

static void STATE_GUIMODEWAITCOMMANDS_event_waterpumpoff(SMSodaStreamPure* sm);

static void STATE_INITGUIMODE_enter(SMSodaStreamPure* sm);

static void STATE_INITGUIMODE_exit(SMSodaStreamPure* sm);

static void STATE_INITGUIMODE_do(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWEROFF_enter(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWEROFF_exit(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWEROFF_do(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWERON_enter(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWERON_exit(SMSodaStreamPure* sm);

static void STATE_SOLENOIDPUMPPOWERON_do(SMSodaStreamPure* sm);

static void STATE_STOP_enter(SMSodaStreamPure* sm);

static void STATE_STOP_exit(SMSodaStreamPure* sm);

static void STATE_STOP_do(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_enter(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_exit(SMSodaStreamPure* sm);

static void STATE_STOPWATERPUMP_do(SMSodaStreamPure* sm);

static void STATE_UVLEDOFF_enter(SMSodaStreamPure* sm);

static void STATE_UVLEDOFF_exit(SMSodaStreamPure* sm);

static void STATE_UVLEDOFF_do(SMSodaStreamPure* sm);

static void STATE_UVLEDON_enter(SMSodaStreamPure* sm);

static void STATE_UVLEDON_exit(SMSodaStreamPure* sm);

static void STATE_UVLEDON_do(SMSodaStreamPure* sm);

static void STATE_WATERPUMPOFF_enter(SMSodaStreamPure* sm);

static void STATE_WATERPUMPOFF_exit(SMSodaStreamPure* sm);

static void STATE_WATERPUMPOFF_do(SMSodaStreamPure* sm);

static void STATE_WATERPUMPON_enter(SMSodaStreamPure* sm);

static void STATE_WATERPUMPON_exit(SMSodaStreamPure* sm);

static void STATE_WATERPUMPON_do(SMSodaStreamPure* sm);

static void STATE_WATERPUMPONNOSENSOR_enter(SMSodaStreamPure* sm);

static void STATE_WATERPUMPONNOSENSOR_exit(SMSodaStreamPure* sm);

static void STATE_WATERPUMPONNOSENSOR_do(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_enter(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_exit(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_hwwatchdog(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_safetyfail(SMSodaStreamPure* sm);

static void STATE_AUTOMATICMODE_event_tiltdetected(SMSodaStreamPure* sm);

static void State_AutomaticMode_InitialState_transition(SMSodaStreamPure* sm);

static void STATE_CARBONATING_enter(SMSodaStreamPure* sm);

static void STATE_CARBONATING_exit(SMSodaStreamPure* sm);

static void STATE_CARBONATING_event_anykeypress(SMSodaStreamPure* sm);

static void State_Carbonating_InitialState_transition(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_enter(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_exit(SMSodaStreamPure* sm);

static void SATE_CARBONATING_OFF_do(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_enter(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_exit(SMSodaStreamPure* sm);

static void SATE_CARBONATING_ON_do(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_enter(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_exit(SMSodaStreamPure* sm);

static void SATE_EXIT_CARBONATING_do(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_enter(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_exit(SMSodaStreamPure* sm);

static void SATE_START_CARBONATING_do(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_enter(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_exit(SMSodaStreamPure* sm);

static void STATE_EXITFILTERINGONLY_do(SMSodaStreamPure* sm);

static void STATE_FILTERING_enter(SMSodaStreamPure* sm);

static void STATE_FILTERING_exit(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_bottlefullsensor(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_carbonationlevelpressed(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_longpresswaterfilter(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_shortpresswaterfilter(SMSodaStreamPure* sm);

static void STATE_FILTERING_event_waterpumpingtimeout(SMSodaStreamPure* sm);

static void STATE_FILTERINGCARBONATIONAWAIT_enter(SMSodaStreamPure* sm);

static void STATE_FILTERINGCARBONATIONAWAIT_exit(SMSodaStreamPure* sm);

static void STATE_FILTERINGCARBONATIONAWAIT_event_anykeypress(SMSodaStreamPure* sm);

static void STATE_FILTERINGCARBONATIONAWAIT_event_bottlefullsensor(SMSodaStreamPure* sm);

static void STATE_FILTERINGCARBONATIONAWAIT_event_waterpumpingtimeout(SMSodaStreamPure* sm);

static void STATE_POWERON_enter(SMSodaStreamPure* sm);

static void STATE_POWERON_exit(SMSodaStreamPure* sm);

static void STATE_POWERON_event_carbonationlevelpressed(SMSodaStreamPure* sm);

static void STATE_POWERON_event_longpresswaterfilter(SMSodaStreamPure* sm);

static void STATE_POWERON_event_shortpresswaterfilter(SMSodaStreamPure* sm);

static void State_PowerOn_ChoicePoint__transition(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_enter(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_exit(SMSodaStreamPure* sm);

static void STATE_POWERONINIT_do(SMSodaStreamPure* sm);

static void STATE_READY_enter(SMSodaStreamPure* sm);

static void STATE_READY_exit(SMSodaStreamPure* sm);

static void STATE_READY_event_readytimout(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_enter(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_exit(SMSodaStreamPure* sm);

static void STATE_READYRINSEREQUIRED_event_readytimout(SMSodaStreamPure* sm);

static void STATE_STANDBY_enter(SMSodaStreamPure* sm);

static void STATE_STANDBY_exit(SMSodaStreamPure* sm);

static void STATE_RINSING_enter(SMSodaStreamPure* sm);

static void STATE_RINSING_exit(SMSodaStreamPure* sm);

static void STATE_RINSING_event_anykeypress(SMSodaStreamPure* sm);

static void STATE_RINSING_event_bottlefullsensor(SMSodaStreamPure* sm);

static void STATE_RINSING_event_waterpumpingtimeout(SMSodaStreamPure* sm);


// State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
void SMSodaStreamPure_ctor(SMSodaStreamPure* sm)
{
    memset(sm, 0, sizeof(*sm));
}

// Starts the state machine. Must be called before dispatching events. Not thread safe.
void SMSodaStreamPure_start(SMSodaStreamPure* sm)
{
    ROOT_enter(sm);
    // ROOT behavior
    // uml: TransitionTo(ROOT.<InitialState>)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
        // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<InitialState> behavior
        // uml: TransitionTo(State_AutomaticMode)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_AutomaticMode`.
            STATE_AUTOMATICMODE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            State_AutomaticMode_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<InitialState>
    } // end of behavior for ROOT
}

// Dispatches an event to the state machine. Not thread safe.
// Note! This function assumes that the `event_id` parameter is valid.
void SMSodaStreamPure_dispatch_event(SMSodaStreamPure* sm, SMSodaStreamPure_EventId event_id)
{
    switch (sm->state_id)
    {
        // STATE: SMSodaStreamPure
        case SMSodaStreamPure_StateId_ROOT:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_HWWatchdog
        case SMSodaStreamPure_StateId_SATE_HWWATCHDOG:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_SafetyFail
        case SMSodaStreamPure_StateId_SATE_SAFETYFAIL:
            // No events handled by this state (or its ancestors).
            break;
        
        // STATE: Sate_Tilted
        case SMSodaStreamPure_StateId_SATE_TILTED:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: SATE_TILTED_event_hwwatchdog(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: SATE_TILTED_event_safetyfail(sm); break;
                case SMSodaStreamPure_EventId_EVENT_NOTTILTED: SATE_TILTED_event_nottilted(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Stat_GUIControlMode
        case SMSodaStreamPure_StateId_STAT_GUICONTROLMODE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_CarbOff
        case SMSodaStreamPure_StateId_STATE_CARBOFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_CARBOFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_CarbOn
        case SMSodaStreamPure_StateId_STATE_CARBON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_CARBON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_GuiModeWaitCommands
        case SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_SOLENDOIDPUMPPOWERON: STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweron(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SOLENDOIDPUMPPOWEROFF: STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweroff(sm); break;
                case SMSodaStreamPure_EventId_EVENT_CARBON: STATE_GUIMODEWAITCOMMANDS_event_carbon(sm); break;
                case SMSodaStreamPure_EventId_EVENT_CARBOFF: STATE_GUIMODEWAITCOMMANDS_event_carboff(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WATERPUMOONNOSENSOR: STATE_GUIMODEWAITCOMMANDS_event_waterpumoonnosensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WAREPUMPON: STATE_GUIMODEWAITCOMMANDS_event_warepumpon(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WATERPUMPOFF: STATE_GUIMODEWAITCOMMANDS_event_waterpumpoff(sm); break;
                case SMSodaStreamPure_EventId_EVENT_UVLEDON: STATE_GUIMODEWAITCOMMANDS_event_uvledon(sm); break;
                case SMSodaStreamPure_EventId_EVENT_UVLEDOFF: STATE_GUIMODEWAITCOMMANDS_event_uvledoff(sm); break;
                case SMSodaStreamPure_EventId_EVENT_STOP: STATE_GUIMODEWAITCOMMANDS_event_stop(sm); break;
                case SMSodaStreamPure_EventId_EVENT_BOTTLEFULLSENSOR: STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_InitGuiMode
        case SMSodaStreamPure_StateId_STATE_INITGUIMODE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_INITGUIMODE_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_SolenoidPumpPowerOff
        case SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWEROFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_SOLENOIDPUMPPOWEROFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_SolenoidPumpPowerOn
        case SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWERON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_SOLENOIDPUMPPOWERON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Stop
        case SMSodaStreamPure_StateId_STATE_STOP:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_STOP_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_StopWaterPump
        case SMSodaStreamPure_StateId_STATE_STOPWATERPUMP:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_STOPWATERPUMP_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_UVLedOff
        case SMSodaStreamPure_StateId_STATE_UVLEDOFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_UVLEDOFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_UVLedOn
        case SMSodaStreamPure_StateId_STATE_UVLEDON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_UVLEDON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_WaterPumpOff
        case SMSodaStreamPure_StateId_STATE_WATERPUMPOFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_WATERPUMPOFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_WaterPumpOn
        case SMSodaStreamPure_StateId_STATE_WATERPUMPON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_WATERPUMPON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_WaterPumpOnNoSensor
        case SMSodaStreamPure_StateId_STATE_WATERPUMPONNOSENSOR:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_WATERPUMPONNOSENSOR_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STAT_GUICONTROLMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STAT_GUICONTROLMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_EXIT_GUI_CONTROLLED_MODE: STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_AutomaticMode
        case SMSodaStreamPure_StateId_STATE_AUTOMATICMODE:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break;
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break;
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Carbonating
        case SMSodaStreamPure_StateId_STATE_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Carbonating_off
        case SMSodaStreamPure_StateId_SATE_CARBONATING_OFF:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_CARBONATING_OFF_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Carbonating_on
        case SMSodaStreamPure_StateId_SATE_CARBONATING_ON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_CARBONATING_ON_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Exit_Carbonating
        case SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_EXIT_CARBONATING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: Sate_Start_Carbonating
        case SMSodaStreamPure_StateId_SATE_START_CARBONATING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: SATE_START_CARBONATING_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_CARBONATING_event_anykeypress(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_ExitFilteringOnly
        case SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_EXITFILTERINGONLY_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Filtering
        case SMSodaStreamPure_StateId_STATE_FILTERING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_FILTERING_event_carbonationlevelpressed(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WATERPUMPINGTIMEOUT: STATE_FILTERING_event_waterpumpingtimeout(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_FILTERING_event_shortpresswaterfilter(sm); break;
                case SMSodaStreamPure_EventId_EVENT_BOTTLEFULLSENSOR: STATE_FILTERING_event_bottlefullsensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_FILTERING_event_longpresswaterfilter(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_FilteringCarbonationAwait
        case SMSodaStreamPure_StateId_STATE_FILTERINGCARBONATIONAWAIT:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_FILTERINGCARBONATIONAWAIT_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_BOTTLEFULLSENSOR: STATE_FILTERINGCARBONATIONAWAIT_event_bottlefullsensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WATERPUMPINGTIMEOUT: STATE_FILTERINGCARBONATIONAWAIT_event_waterpumpingtimeout(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_PowerOn
        case SMSodaStreamPure_StateId_STATE_POWERON:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_POWERON_event_longpresswaterfilter(sm); break;
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_POWERON_event_shortpresswaterfilter(sm); break;
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_POWERON_event_carbonationlevelpressed(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_PowerOnInit
        case SMSodaStreamPure_StateId_STATE_POWERONINIT:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_DO: STATE_POWERONINIT_do(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_POWERON_event_longpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_POWERON_event_shortpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_POWERON_event_carbonationlevelpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Ready
        case SMSodaStreamPure_StateId_STATE_READY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_READYTIMOUT: STATE_READY_event_readytimout(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_POWERON_event_longpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_POWERON_event_shortpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_POWERON_event_carbonationlevelpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_ReadyRinseRequired
        case SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_READYTIMOUT: STATE_READYRINSEREQUIRED_event_readytimout(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_POWERON_event_longpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_POWERON_event_shortpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_POWERON_event_carbonationlevelpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_StandBy
        case SMSodaStreamPure_StateId_STATE_STANDBY:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_LONGPRESSWATERFILTER: STATE_POWERON_event_longpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SHORTPRESSWATERFILTER: STATE_POWERON_event_shortpresswaterfilter(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_CARBONATIONLEVELPRESSED: STATE_POWERON_event_carbonationlevelpressed(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
        
        // STATE: State_Rinsing
        case SMSodaStreamPure_StateId_STATE_RINSING:
            switch (event_id)
            {
                case SMSodaStreamPure_EventId_EVENT_ANYKEYPRESS: STATE_RINSING_event_anykeypress(sm); break;
                case SMSodaStreamPure_EventId_EVENT_BOTTLEFULLSENSOR: STATE_RINSING_event_bottlefullsensor(sm); break;
                case SMSodaStreamPure_EventId_EVENT_WATERPUMPINGTIMEOUT: STATE_RINSING_event_waterpumpingtimeout(sm); break;
                case SMSodaStreamPure_EventId_EVENT_HWWATCHDOG: STATE_AUTOMATICMODE_event_hwwatchdog(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_SAFETYFAIL: STATE_AUTOMATICMODE_event_safetyfail(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_TILTDETECTED: STATE_AUTOMATICMODE_event_tiltdetected(sm); break; // First ancestor handler for this event
                case SMSodaStreamPure_EventId_EVENT_ENTER_GUI_CONTROLLED_MODE: STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(sm); break; // First ancestor handler for this event
                
                default: break; // to avoid "unused enumeration value in switch" warning
            }
            break;
    }
    
}

// This function is used when StateSmith doesn't know what the active leaf state is at
// compile time due to sub states or when multiple states need to be exited.
static void exit_up_to_state_handler(SMSodaStreamPure* sm, SMSodaStreamPure_StateId desired_state)
{
    while (sm->state_id != desired_state)
    {
        switch (sm->state_id)
        {
            case SMSodaStreamPure_StateId_SATE_HWWATCHDOG: SATE_HWWATCHDOG_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_SAFETYFAIL: SATE_SAFETYFAIL_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_TILTED: SATE_TILTED_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STAT_GUICONTROLMODE: STAT_GUICONTROLMODE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_CARBOFF: STATE_CARBOFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_CARBON: STATE_CARBON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS: STATE_GUIMODEWAITCOMMANDS_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_INITGUIMODE: STATE_INITGUIMODE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWEROFF: STATE_SOLENOIDPUMPPOWEROFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWERON: STATE_SOLENOIDPUMPPOWERON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_STOP: STATE_STOP_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_STOPWATERPUMP: STATE_STOPWATERPUMP_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_UVLEDOFF: STATE_UVLEDOFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_UVLEDON: STATE_UVLEDON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_WATERPUMPOFF: STATE_WATERPUMPOFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_WATERPUMPON: STATE_WATERPUMPON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_WATERPUMPONNOSENSOR: STATE_WATERPUMPONNOSENSOR_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_AUTOMATICMODE: STATE_AUTOMATICMODE_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_CARBONATING: STATE_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_CARBONATING_OFF: SATE_CARBONATING_OFF_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_CARBONATING_ON: SATE_CARBONATING_ON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING: SATE_EXIT_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_SATE_START_CARBONATING: SATE_START_CARBONATING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY: STATE_EXITFILTERINGONLY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_FILTERING: STATE_FILTERING_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_FILTERINGCARBONATIONAWAIT: STATE_FILTERINGCARBONATIONAWAIT_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_POWERON: STATE_POWERON_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_POWERONINIT: STATE_POWERONINIT_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_READY: STATE_READY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED: STATE_READYRINSEREQUIRED_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_STANDBY: STATE_STANDBY_exit(sm); break;
            
            case SMSodaStreamPure_StateId_STATE_RINSING: STATE_RINSING_exit(sm); break;
            
            default: return;  // Just to be safe. Prevents infinite loop if state ID memory is somehow corrupted.
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state ROOT
////////////////////////////////////////////////////////////////////////////////

static void ROOT_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_HWWATCHDOG
////////////////////////////////////////////////////////////////////////////////

static void SATE_HWWATCHDOG_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_HWWATCHDOG;
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_HWWatchdog
    
    // Sate_HWWatchdog behavior
    // uml: enter / { FadeOutAmbiantLight(); }
    {
        // Step 1: execute action `FadeOutAmbiantLight();`
        FadeOutAmbiantLight();
    } // end of behavior for Sate_HWWatchdog
}

static void SATE_HWWATCHDOG_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_SAFETYFAIL
////////////////////////////////////////////////////////////////////////////////

static void SATE_SAFETYFAIL_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_SAFETYFAIL;
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_SafetyFail
    
    // Sate_SafetyFail behavior
    // uml: enter / { FadeOutAmbiantLight(); }
    {
        // Step 1: execute action `FadeOutAmbiantLight();`
        FadeOutAmbiantLight();
    } // end of behavior for Sate_SafetyFail
}

static void SATE_SAFETYFAIL_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_TILTED
////////////////////////////////////////////////////////////////////////////////

static void SATE_TILTED_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_TILTED;
    
    // Sate_Tilted behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { StartMalfunctionLedsSequence(); }
    {
        // Step 1: execute action `StartMalfunctionLedsSequence();`
        StartMalfunctionLedsSequence();
    } // end of behavior for Sate_Tilted
    
    // Sate_Tilted behavior
    // uml: enter / { FadeOutAmbiantLight(); }
    {
        // Step 1: execute action `FadeOutAmbiantLight();`
        FadeOutAmbiantLight();
    } // end of behavior for Sate_Tilted
}

static void SATE_TILTED_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void SATE_TILTED_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}

static void SATE_TILTED_event_nottilted(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: Event_NotTilted TransitionTo(ROOT.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `ROOT.<ChoicePoint>()`.
        // ROOT.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // ROOT.<ChoicePoint>() behavior
        // uml: [IsGuiControlMode()] TransitionTo(Stat_GUIControlMode)
        if (IsGuiControlMode())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Stat_GUIControlMode`.
            STAT_GUICONTROLMODE_enter(sm);
            
            // Finish transition by calling pseudo state transition function.
            Stat_GUIControlMode_InitialState_transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<ChoicePoint>()
        
        // ROOT.<ChoicePoint>() behavior
        // uml: else TransitionTo(State_PowerOn.<ChoicePoint>())
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_PowerOn.<ChoicePoint>()`.
            STATE_AUTOMATICMODE_enter(sm);
            STATE_POWERON_enter(sm);
            // State_PowerOn.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
            
            // Finish transition by calling pseudo state transition function.
            State_PowerOn_ChoicePoint__transition(sm);
            return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
        } // end of behavior for ROOT.<ChoicePoint>()
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}

static void SATE_TILTED_event_safetyfail(SMSodaStreamPure* sm)
{
    // Sate_Tilted behavior
    // uml: Event_SafetyFail TransitionTo(Sate_SafetyFail)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        SATE_TILTED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_SafetyFail`.
        SATE_SAFETYFAIL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Tilted
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STAT_GUICONTROLMODE
////////////////////////////////////////////////////////////////////////////////

static void STAT_GUICONTROLMODE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STAT_GUICONTROLMODE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void STAT_GUICONTROLMODE_event_exit_gui_controlled_mode(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode behavior
    // uml: Event_Exit_GUI_Controlled_Mode TransitionTo(State_AutomaticMode)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_AutomaticMode`.
        STATE_AUTOMATICMODE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_AutomaticMode_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for Stat_GUIControlMode
    
    // No ancestor handles this event.
}

static void STAT_GUICONTROLMODE_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Stat_GUIControlMode
    
    // No ancestor handles this event.
}

static void STAT_GUICONTROLMODE_event_safetyfail(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode behavior
    // uml: Event_SafetyFail TransitionTo(Sate_SafetyFail)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_SafetyFail`.
        SATE_SAFETYFAIL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Stat_GUIControlMode
    
    // No ancestor handles this event.
}

static void Stat_GUIControlMode_InitialState_transition(SMSodaStreamPure* sm)
{
    // Stat_GUIControlMode.<InitialState> behavior
    // uml: TransitionTo(State_InitGuiMode)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_InitGuiMode`.
        STATE_INITGUIMODE_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Stat_GUIControlMode.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_CARBOFF
////////////////////////////////////////////////////////////////////////////////

static void STATE_CARBOFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBOFF;
    
    // State_CarbOff behavior
    // uml: enter / { SolenoidPump(0); }
    {
        // Step 1: execute action `SolenoidPump(0);`
        SolenoidPump(0);
    } // end of behavior for State_CarbOff
}

static void STATE_CARBOFF_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_CARBOFF_do(SMSodaStreamPure* sm)
{
    // State_CarbOff behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_CARBOFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_CarbOff
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_CARBON
////////////////////////////////////////////////////////////////////////////////

static void STATE_CARBON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBON;
    
    // State_CarbOn behavior
    // uml: enter / { SolenoidPump(1); }
    {
        // Step 1: execute action `SolenoidPump(1);`
        SolenoidPump(1);
    } // end of behavior for State_CarbOn
}

static void STATE_CARBON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_CARBON_do(SMSodaStreamPure* sm)
{
    // State_CarbOn behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_CARBON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_CarbOn
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_GUIMODEWAITCOMMANDS
////////////////////////////////////////////////////////////////////////////////

static void STATE_GUIMODEWAITCOMMANDS_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_GUIMODEWAITCOMMANDS;
}

static void STATE_GUIMODEWAITCOMMANDS_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_GUIMODEWAITCOMMANDS_event_bottlefullsensor(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_BottleFullSensor TransitionTo(Stat_GUIControlMode.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Stat_GUIControlMode.<ChoicePoint>()`.
        // Stat_GUIControlMode.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Stat_GUIControlMode.<ChoicePoint>() behavior
        // uml: [pumpStopsOnSensor] TransitionTo(State_StopWaterPump)
        if (sm->vars.pumpStopsOnSensor)
        {
            // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_StopWaterPump`.
            STATE_STOPWATERPUMP_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Stat_GUIControlMode.<ChoicePoint>()
        
        // Stat_GUIControlMode.<ChoicePoint>() behavior
        // uml: else TransitionTo(State_GuiModeWaitCommands)
        {
            // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
            STATE_GUIMODEWAITCOMMANDS_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for Stat_GUIControlMode.<ChoicePoint>()
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_carboff(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_CarbOff TransitionTo(State_CarbOff)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_CarbOff`.
        STATE_CARBOFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_carbon(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_CarbOn TransitionTo(State_CarbOn)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_CarbOn`.
        STATE_CARBON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweroff(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_SolendoidPumpPowerOff TransitionTo(State_SolenoidPumpPowerOff)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_SolenoidPumpPowerOff`.
        STATE_SOLENOIDPUMPPOWEROFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_solendoidpumppoweron(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_SolendoidPumpPowerOn TransitionTo(State_SolenoidPumpPowerOn)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_SolenoidPumpPowerOn`.
        STATE_SOLENOIDPUMPPOWERON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_stop(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_STOP TransitionTo(State_Stop)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Stop`.
        STATE_STOP_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_uvledoff(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_UVLedOff TransitionTo(State_UVLedOff)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_UVLedOff`.
        STATE_UVLEDOFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_uvledon(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_UVLedOn TransitionTo(State_UVLedOn)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_UVLedOn`.
        STATE_UVLEDON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_warepumpon(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_WarePumpOn TransitionTo(State_WaterPumpOn)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_WaterPumpOn`.
        STATE_WATERPUMPON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_waterpumoonnosensor(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_WaterPumoOnNoSensor TransitionTo(State_WaterPumpOnNoSensor)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_WaterPumpOnNoSensor`.
        STATE_WATERPUMPONNOSENSOR_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}

static void STATE_GUIMODEWAITCOMMANDS_event_waterpumpoff(SMSodaStreamPure* sm)
{
    // State_GuiModeWaitCommands behavior
    // uml: Event_WaterPumpOff TransitionTo(State_WaterPumpOff)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_GUIMODEWAITCOMMANDS_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_WaterPumpOff`.
        STATE_WATERPUMPOFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_GuiModeWaitCommands
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_INITGUIMODE
////////////////////////////////////////////////////////////////////////////////

static void STATE_INITGUIMODE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_INITGUIMODE;
    
    // State_InitGuiMode behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_InitGuiMode
    
    // State_InitGuiMode behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_InitGuiMode
    
    // State_InitGuiMode behavior
    // uml: enter / { LedsOff(LEDS_all); }
    {
        // Step 1: execute action `LedsOff(LEDS_all);`
        LedsOff(LEDS_all);
    } // end of behavior for State_InitGuiMode
}

static void STATE_INITGUIMODE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_INITGUIMODE_do(SMSodaStreamPure* sm)
{
    // State_InitGuiMode behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_INITGUIMODE_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_InitGuiMode
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_SOLENOIDPUMPPOWEROFF
////////////////////////////////////////////////////////////////////////////////

static void STATE_SOLENOIDPUMPPOWEROFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWEROFF;
    
    // State_SolenoidPumpPowerOff behavior
    // uml: enter / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for State_SolenoidPumpPowerOff
}

static void STATE_SOLENOIDPUMPPOWEROFF_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_SOLENOIDPUMPPOWEROFF_do(SMSodaStreamPure* sm)
{
    // State_SolenoidPumpPowerOff behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_SOLENOIDPUMPPOWEROFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_SolenoidPumpPowerOff
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_SOLENOIDPUMPPOWERON
////////////////////////////////////////////////////////////////////////////////

static void STATE_SOLENOIDPUMPPOWERON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_SOLENOIDPUMPPOWERON;
    
    // State_SolenoidPumpPowerOn behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for State_SolenoidPumpPowerOn
}

static void STATE_SOLENOIDPUMPPOWERON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_SOLENOIDPUMPPOWERON_do(SMSodaStreamPure* sm)
{
    // State_SolenoidPumpPowerOn behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_SOLENOIDPUMPPOWERON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_SolenoidPumpPowerOn
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_STOP
////////////////////////////////////////////////////////////////////////////////

static void STATE_STOP_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_STOP;
    
    // State_Stop behavior
    // uml: enter / { SolenoidPump(0); }
    {
        // Step 1: execute action `SolenoidPump(0);`
        SolenoidPump(0);
    } // end of behavior for State_Stop
    
    // State_Stop behavior
    // uml: enter / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for State_Stop
    
    // State_Stop behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_Stop
}

static void STATE_STOP_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_STOP_do(SMSodaStreamPure* sm)
{
    // State_Stop behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_STOP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Stop
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_STOPWATERPUMP
////////////////////////////////////////////////////////////////////////////////

static void STATE_STOPWATERPUMP_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_STOPWATERPUMP;
    
    // State_StopWaterPump behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_StopWaterPump
}

static void STATE_STOPWATERPUMP_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_STOPWATERPUMP_do(SMSodaStreamPure* sm)
{
    // State_StopWaterPump behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_STOPWATERPUMP_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_StopWaterPump
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_UVLEDOFF
////////////////////////////////////////////////////////////////////////////////

static void STATE_UVLEDOFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_UVLEDOFF;
    
    // State_UVLedOff behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_UVLedOff
}

static void STATE_UVLEDOFF_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_UVLEDOFF_do(SMSodaStreamPure* sm)
{
    // State_UVLedOff behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_UVLEDOFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_UVLedOff
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_UVLEDON
////////////////////////////////////////////////////////////////////////////////

static void STATE_UVLEDON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_UVLEDON;
    
    // State_UVLedOn behavior
    // uml: enter / { StartUVLEd(); }
    {
        // Step 1: execute action `StartUVLEd();`
        StartUVLEd();
    } // end of behavior for State_UVLedOn
}

static void STATE_UVLEDON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_UVLEDON_do(SMSodaStreamPure* sm)
{
    // State_UVLedOn behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_UVLEDON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_UVLedOn
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_WATERPUMPOFF
////////////////////////////////////////////////////////////////////////////////

static void STATE_WATERPUMPOFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_WATERPUMPOFF;
    
    // State_WaterPumpOff behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_WaterPumpOff
}

static void STATE_WATERPUMPOFF_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_WATERPUMPOFF_do(SMSodaStreamPure* sm)
{
    // State_WaterPumpOff behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_WATERPUMPOFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_WaterPumpOff
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_WATERPUMPON
////////////////////////////////////////////////////////////////////////////////

static void STATE_WATERPUMPON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_WATERPUMPON;
    
    // State_WaterPumpOn behavior
    // uml: enter / { pumpStopsOnSensor = true; }
    {
        // Step 1: execute action `pumpStopsOnSensor = true;`
        sm->vars.pumpStopsOnSensor = true;
    } // end of behavior for State_WaterPumpOn
    
    // State_WaterPumpOn behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_WaterPumpOn
}

static void STATE_WATERPUMPON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_WATERPUMPON_do(SMSodaStreamPure* sm)
{
    // State_WaterPumpOn behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_WATERPUMPON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_WaterPumpOn
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_WATERPUMPONNOSENSOR
////////////////////////////////////////////////////////////////////////////////

static void STATE_WATERPUMPONNOSENSOR_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_WATERPUMPONNOSENSOR;
    
    // State_WaterPumpOnNoSensor behavior
    // uml: enter / { pumpStopsOnSensor = false; }
    {
        // Step 1: execute action `pumpStopsOnSensor = false;`
        sm->vars.pumpStopsOnSensor = false;
    } // end of behavior for State_WaterPumpOnNoSensor
    
    // State_WaterPumpOnNoSensor behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_WaterPumpOnNoSensor
}

static void STATE_WATERPUMPONNOSENSOR_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STAT_GUICONTROLMODE;
}

static void STATE_WATERPUMPONNOSENSOR_do(SMSodaStreamPure* sm)
{
    // State_WaterPumpOnNoSensor behavior
    // uml: do TransitionTo(State_GuiModeWaitCommands)
    {
        // Step 1: Exit states until we reach `Stat_GUIControlMode` state (Least Common Ancestor for transition).
        STATE_WATERPUMPONNOSENSOR_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_GuiModeWaitCommands`.
        STATE_GUIMODEWAITCOMMANDS_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_WaterPumpOnNoSensor
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_AUTOMATICMODE
////////////////////////////////////////////////////////////////////////////////

static void STATE_AUTOMATICMODE_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_AUTOMATICMODE_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_ROOT;
}

static void STATE_AUTOMATICMODE_event_enter_gui_controlled_mode(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_Enter_GUI_Controlled_Mode TransitionTo(Stat_GUIControlMode)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Stat_GUIControlMode`.
        STAT_GUICONTROLMODE_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        Stat_GUIControlMode_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_hwwatchdog(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_HWWatchdog TransitionTo(Sate_HWWatchdog)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_HWWatchdog`.
        SATE_HWWATCHDOG_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_safetyfail(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_SafetyFail TransitionTo(Sate_SafetyFail)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_SafetyFail`.
        SATE_SAFETYFAIL_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void STATE_AUTOMATICMODE_event_tiltdetected(SMSodaStreamPure* sm)
{
    // State_AutomaticMode behavior
    // uml: Event_TiltDetected TransitionTo(Sate_Tilted)
    {
        // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_ROOT);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Tilted`.
        SATE_TILTED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_AutomaticMode
    
    // No ancestor handles this event.
}

static void State_AutomaticMode_InitialState_transition(SMSodaStreamPure* sm)
{
    // State_AutomaticMode.<InitialState> behavior
    // uml: TransitionTo(State_PowerOn)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_PowerOn`.
        STATE_POWERON_enter(sm);
        
        // State_PowerOn.<InitialState> behavior
        // uml: TransitionTo(State_PowerOnInit)
        {
            // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `State_PowerOnInit`.
            STATE_POWERONINIT_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_PowerOn.<InitialState>
    } // end of behavior for State_AutomaticMode.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void STATE_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void STATE_CARBONATING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_CARBONATING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Carbonating behavior
    // uml: Event_AnyKeyPress TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Carbonating
    
    // No ancestor handles this event.
}

static void State_Carbonating_InitialState_transition(SMSodaStreamPure* sm)
{
    // State_Carbonating.<InitialState> behavior
    // uml: TransitionTo(Sate_Start_Carbonating)
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Start_Carbonating`.
        SATE_START_CARBONATING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Carbonating.<InitialState>
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_CARBONATING_OFF
////////////////////////////////////////////////////////////////////////////////

static void SATE_CARBONATING_OFF_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_CARBONATING_OFF;
    
    // Sate_Carbonating_off behavior
    // uml: enter / { StartCarbStageTimer(); }
    {
        // Step 1: execute action `StartCarbStageTimer();`
        StartCarbStageTimer();
    } // end of behavior for Sate_Carbonating_off
    
    // Sate_Carbonating_off behavior
    // uml: enter / { SolenoidPump(0); }
    {
        // Step 1: execute action `SolenoidPump(0);`
        SolenoidPump(0);
    } // end of behavior for Sate_Carbonating_off
}

static void SATE_CARBONATING_OFF_exit(SMSodaStreamPure* sm)
{
    // Sate_Carbonating_off behavior
    // uml: exit / { carbCycle++; }
    {
        // Step 1: execute action `carbCycle++;`
        sm->vars.carbCycle++;
    } // end of behavior for Sate_Carbonating_off
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_CARBONATING_OFF_do(SMSodaStreamPure* sm)
{
    // Sate_Carbonating_off behavior
    // uml: do [CarbonationOffCycleExpired(carbCycle)] TransitionTo(State_Carbonating.<ChoicePoint>())
    if (CarbonationOffCycleExpired(sm->vars.carbCycle))
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_CARBONATING_OFF_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Carbonating.<ChoicePoint>()`.
        // State_Carbonating.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // State_Carbonating.<ChoicePoint>() behavior
        // uml: [IsCarbonationLastCycle(carbCycle)] TransitionTo(Sate_Exit_Carbonating)
        if (IsCarbonationLastCycle(sm->vars.carbCycle))
        {
            // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Sate_Exit_Carbonating`.
            SATE_EXIT_CARBONATING_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_Carbonating.<ChoicePoint>()
        
        // State_Carbonating.<ChoicePoint>() behavior
        // uml: else TransitionTo(Sate_Carbonating_on)
        {
            // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
            
            // Step 2: Transition action: ``.
            
            // Step 3: Enter/move towards transition target `Sate_Carbonating_on`.
            SATE_CARBONATING_ON_enter(sm);
            
            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            return;
        } // end of behavior for State_Carbonating.<ChoicePoint>()
    } // end of behavior for Sate_Carbonating_off
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_CARBONATING_ON
////////////////////////////////////////////////////////////////////////////////

static void SATE_CARBONATING_ON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_CARBONATING_ON;
    
    // Sate_Carbonating_on behavior
    // uml: enter / { StartCarbStageTimer(); }
    {
        // Step 1: execute action `StartCarbStageTimer();`
        StartCarbStageTimer();
    } // end of behavior for Sate_Carbonating_on
    
    // Sate_Carbonating_on behavior
    // uml: enter / { SolenoidPump(1); }
    {
        // Step 1: execute action `SolenoidPump(1);`
        SolenoidPump(1);
    } // end of behavior for Sate_Carbonating_on
}

static void SATE_CARBONATING_ON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_CARBONATING_ON_do(SMSodaStreamPure* sm)
{
    // Sate_Carbonating_on behavior
    // uml: do [CarbonationOnCycleExpired(carbCycle)] TransitionTo(Sate_Carbonating_off)
    if (CarbonationOnCycleExpired(sm->vars.carbCycle))
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_CARBONATING_ON_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Carbonating_off`.
        SATE_CARBONATING_OFF_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Carbonating_on
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_EXIT_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void SATE_EXIT_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_EXIT_CARBONATING;
}

static void SATE_EXIT_CARBONATING_exit(SMSodaStreamPure* sm)
{
    // Sate_Exit_Carbonating behavior
    // uml: exit / { StopCarbonation(); }
    {
        // Step 1: execute action `StopCarbonation();`
        StopCarbonation();
    } // end of behavior for Sate_Exit_Carbonating
    
    // Sate_Exit_Carbonating behavior
    // uml: exit / { FadeOutAmbiantLight(); }
    {
        // Step 1: execute action `FadeOutAmbiantLight();`
        FadeOutAmbiantLight();
    } // end of behavior for Sate_Exit_Carbonating
    
    // Sate_Exit_Carbonating behavior
    // uml: exit / { FadeInLeds(); }
    {
        // Step 1: execute action `FadeInLeds();`
        FadeInLeds();
    } // end of behavior for Sate_Exit_Carbonating
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_EXIT_CARBONATING_do(SMSodaStreamPure* sm)
{
    // Sate_Exit_Carbonating behavior
    // uml: do TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Exit_Carbonating
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state SATE_START_CARBONATING
////////////////////////////////////////////////////////////////////////////////

static void SATE_START_CARBONATING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_SATE_START_CARBONATING;
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { InitCarbonationOnly(); }
    {
        // Step 1: execute action `InitCarbonationOnly();`
        InitCarbonationOnly();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { FadeInLeds(LEDS_all); }
    {
        // Step 1: execute action `FadeInLeds(LEDS_all);`
        FadeInLeds(LEDS_all);
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { FadeInAmbiantLight(); }
    {
        // Step 1: execute action `FadeInAmbiantLight();`
        FadeInAmbiantLight();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { StartCarbonationLedSequance(); }
    {
        // Step 1: execute action `StartCarbonationLedSequance();`
        StartCarbonationLedSequance();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { StartCarbonation(); }
    {
        // Step 1: execute action `StartCarbonation();`
        StartCarbonation();
    } // end of behavior for Sate_Start_Carbonating
    
    // Sate_Start_Carbonating behavior
    // uml: enter / { carbCycle = 0; }
    {
        // Step 1: execute action `carbCycle = 0;`
        sm->vars.carbCycle = 0;
    } // end of behavior for Sate_Start_Carbonating
}

static void SATE_START_CARBONATING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_CARBONATING;
}

static void SATE_START_CARBONATING_do(SMSodaStreamPure* sm)
{
    // Sate_Start_Carbonating behavior
    // uml: do TransitionTo(Sate_Carbonating_on)
    {
        // Step 1: Exit states until we reach `State_Carbonating` state (Least Common Ancestor for transition).
        SATE_START_CARBONATING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `Sate_Carbonating_on`.
        SATE_CARBONATING_ON_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for Sate_Start_Carbonating
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_EXITFILTERINGONLY
////////////////////////////////////////////////////////////////////////////////

static void STATE_EXITFILTERINGONLY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_EXITFILTERINGONLY;
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for State_ExitFilteringOnly
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_ExitFilteringOnly
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_ExitFilteringOnly
    
    // State_ExitFilteringOnly behavior
    // uml: enter / { FadeOutAmbiantLight(); }
    {
        // Step 1: execute action `FadeOutAmbiantLight();`
        FadeOutAmbiantLight();
    } // end of behavior for State_ExitFilteringOnly
}

static void STATE_EXITFILTERINGONLY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_EXITFILTERINGONLY_do(SMSodaStreamPure* sm)
{
    // State_ExitFilteringOnly behavior
    // uml: do TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_EXITFILTERINGONLY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_ExitFilteringOnly
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_FILTERING
////////////////////////////////////////////////////////////////////////////////

static void STATE_FILTERING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_FILTERING;
    
    // State_Filtering behavior
    // uml: enter / { StartWaterFilterLedSequence(); }
    {
        // Step 1: execute action `StartWaterFilterLedSequence();`
        StartWaterFilterLedSequence();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { FadeInLeds(LEDS_all); }
    {
        // Step 1: execute action `FadeInLeds(LEDS_all);`
        FadeInLeds(LEDS_all);
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { FadeInAmbiantLight(); }
    {
        // Step 1: execute action `FadeInAmbiantLight();`
        FadeInAmbiantLight();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartUVLEd(); }
    {
        // Step 1: execute action `StartUVLEd();`
        StartUVLEd();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { pumpStopsOnSensor = true; }
    {
        // Step 1: execute action `pumpStopsOnSensor = true;`
        sm->vars.pumpStopsOnSensor = true;
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_Filtering
    
    // State_Filtering behavior
    // uml: enter / { StartWaterPumpingTimer(); }
    {
        // Step 1: execute action `StartWaterPumpingTimer();`
        StartWaterPumpingTimer();
    } // end of behavior for State_Filtering
}

static void STATE_FILTERING_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_FILTERING_event_bottlefullsensor(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_BottleFullSensor TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}

static void STATE_FILTERING_event_carbonationlevelpressed(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_CarbonationLevelPressed TransitionTo(State_FilteringCarbonationAwait)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_FilteringCarbonationAwait`.
        STATE_FILTERINGCARBONATIONAWAIT_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}

static void STATE_FILTERING_event_longpresswaterfilter(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_LongPressWaterFilter TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}

static void STATE_FILTERING_event_shortpresswaterfilter(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_ShortPressWaterFilter TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}

static void STATE_FILTERING_event_waterpumpingtimeout(SMSodaStreamPure* sm)
{
    // State_Filtering behavior
    // uml: Event_WaterPumpingTimeout TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Filtering
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_FILTERINGCARBONATIONAWAIT
////////////////////////////////////////////////////////////////////////////////

static void STATE_FILTERINGCARBONATIONAWAIT_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_FILTERINGCARBONATIONAWAIT;
    
    // State_FilteringCarbonationAwait behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for State_FilteringCarbonationAwait
}

static void STATE_FILTERINGCARBONATIONAWAIT_exit(SMSodaStreamPure* sm)
{
    // State_FilteringCarbonationAwait behavior
    // uml: exit / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_FilteringCarbonationAwait
    
    // State_FilteringCarbonationAwait behavior
    // uml: exit / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_FilteringCarbonationAwait
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_FILTERINGCARBONATIONAWAIT_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_FilteringCarbonationAwait behavior
    // uml: Event_AnyKeyPress TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERINGCARBONATIONAWAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_FilteringCarbonationAwait
    
    // No ancestor handles this event.
}

static void STATE_FILTERINGCARBONATIONAWAIT_event_bottlefullsensor(SMSodaStreamPure* sm)
{
    // State_FilteringCarbonationAwait behavior
    // uml: Event_BottleFullSensor TransitionTo(State_Carbonating)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERINGCARBONATIONAWAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Carbonating`.
        STATE_CARBONATING_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Carbonating_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_FilteringCarbonationAwait
    
    // No ancestor handles this event.
}

static void STATE_FILTERINGCARBONATIONAWAIT_event_waterpumpingtimeout(SMSodaStreamPure* sm)
{
    // State_FilteringCarbonationAwait behavior
    // uml: Event_WaterPumpingTimeout TransitionTo(State_ExitFilteringOnly)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_FILTERINGCARBONATIONAWAIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ExitFilteringOnly`.
        STATE_EXITFILTERINGONLY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_FilteringCarbonationAwait
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_POWERON
////////////////////////////////////////////////////////////////////////////////

static void STATE_POWERON_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERON;
}

static void STATE_POWERON_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_POWERON_event_carbonationlevelpressed(SMSodaStreamPure* sm)
{
    // State_PowerOn behavior
    // uml: Event_CarbonationLevelPressed TransitionTo(State_Carbonating)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Carbonating`.
        STATE_CARBONATING_enter(sm);
        
        // Finish transition by calling pseudo state transition function.
        State_Carbonating_InitialState_transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_PowerOn
    
    // No ancestor handles this event.
}

static void STATE_POWERON_event_longpresswaterfilter(SMSodaStreamPure* sm)
{
    // State_PowerOn behavior
    // uml: Event_LongPressWaterFilter TransitionTo(State_Rinsing)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Rinsing`.
        STATE_RINSING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_PowerOn
    
    // No ancestor handles this event.
}

static void STATE_POWERON_event_shortpresswaterfilter(SMSodaStreamPure* sm)
{
    // State_PowerOn behavior
    // uml: Event_ShortPressWaterFilter TransitionTo(State_Filtering)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        exit_up_to_state_handler(sm, SMSodaStreamPure_StateId_STATE_AUTOMATICMODE);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Filtering`.
        STATE_FILTERING_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_PowerOn
    
    // No ancestor handles this event.
}

static void State_PowerOn_ChoicePoint__transition(SMSodaStreamPure* sm)
{
    // State_PowerOn.<ChoicePoint>() behavior
    // uml: [IsFirstPowerON() || FilterLifeTimeExpired()] TransitionTo(State_ReadyRinseRequired)
    if (IsFirstPowerON() || FilterLifeTimeExpired())
    {
        // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_ReadyRinseRequired`.
        STATE_READYRINSEREQUIRED_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_PowerOn.<ChoicePoint>()
    
    // State_PowerOn.<ChoicePoint>() behavior
    // uml: else TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition). Already at LCA, no exiting required.
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_PowerOn.<ChoicePoint>()
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_POWERONINIT
////////////////////////////////////////////////////////////////////////////////

static void STATE_POWERONINIT_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERONINIT;
    
    // State_PowerOnInit behavior
    // uml: enter / { LedsOff(LEDS_all); }
    {
        // Step 1: execute action `LedsOff(LEDS_all);`
        LedsOff(LEDS_all);
    } // end of behavior for State_PowerOnInit
    
    // State_PowerOnInit behavior
    // uml: enter / { AmbiantLightOff(); }
    {
        // Step 1: execute action `AmbiantLightOff();`
        AmbiantLightOff();
    } // end of behavior for State_PowerOnInit
}

static void STATE_POWERONINIT_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERON;
}

static void STATE_POWERONINIT_do(SMSodaStreamPure* sm)
{
    // State_PowerOnInit behavior
    // uml: do TransitionTo(State_PowerOn.<ChoicePoint>())
    {
        // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition).
        STATE_POWERONINIT_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_PowerOn.<ChoicePoint>()`.
        // State_PowerOn.<ChoicePoint>() is a pseudo state and cannot have an `enter` trigger.
        
        // Finish transition by calling pseudo state transition function.
        State_PowerOn_ChoicePoint__transition(sm);
        return; // event processing immediately stops when a transition finishes. No other behaviors for this state are checked.
    } // end of behavior for State_PowerOnInit
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_READY
////////////////////////////////////////////////////////////////////////////////

static void STATE_READY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_READY;
    
    // State_Ready behavior
    // uml: enter / { FadeInLeds(LEDS_all); }
    {
        // Step 1: execute action `FadeInLeds(LEDS_all);`
        FadeInLeds(LEDS_all);
    } // end of behavior for State_Ready
    
    // State_Ready behavior
    // uml: enter / { StartReadyTimer(); }
    {
        // Step 1: execute action `StartReadyTimer();`
        StartReadyTimer();
    } // end of behavior for State_Ready
    
    // State_Ready behavior
    // uml: enter / { ButtonsFunction(true); }
    {
        // Step 1: execute action `ButtonsFunction(true);`
        ButtonsFunction(true);
    } // end of behavior for State_Ready
}

static void STATE_READY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERON;
}

static void STATE_READY_event_readytimout(SMSodaStreamPure* sm)
{
    // State_Ready behavior
    // uml: Event_ReadyTimout TransitionTo(State_StandBy)
    {
        // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition).
        STATE_READY_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_StandBy`.
        STATE_STANDBY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Ready
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_READYRINSEREQUIRED
////////////////////////////////////////////////////////////////////////////////

static void STATE_READYRINSEREQUIRED_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_READYRINSEREQUIRED;
    
    // State_ReadyRinseRequired behavior
    // uml: enter / { FadeInLeds(LEDS_OrangeWater); }
    {
        // Step 1: execute action `FadeInLeds(LEDS_OrangeWater);`
        FadeInLeds(LEDS_OrangeWater);
    } // end of behavior for State_ReadyRinseRequired
    
    // State_ReadyRinseRequired behavior
    // uml: enter / { StartReadyTimer(); }
    {
        // Step 1: execute action `StartReadyTimer();`
        StartReadyTimer();
    } // end of behavior for State_ReadyRinseRequired
    
    // State_ReadyRinseRequired behavior
    // uml: enter / { ButtonsFunction(true); }
    {
        // Step 1: execute action `ButtonsFunction(true);`
        ButtonsFunction(true);
    } // end of behavior for State_ReadyRinseRequired
}

static void STATE_READYRINSEREQUIRED_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERON;
}

static void STATE_READYRINSEREQUIRED_event_readytimout(SMSodaStreamPure* sm)
{
    // State_ReadyRinseRequired behavior
    // uml: Event_ReadyTimout TransitionTo(State_StandBy)
    {
        // Step 1: Exit states until we reach `State_PowerOn` state (Least Common Ancestor for transition).
        STATE_READYRINSEREQUIRED_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_StandBy`.
        STATE_STANDBY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_ReadyRinseRequired
    
    // No ancestor handles this event.
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_STANDBY
////////////////////////////////////////////////////////////////////////////////

static void STATE_STANDBY_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_STANDBY;
    
    // State_StandBy behavior
    // uml: enter / { FadeOutLeds(LEDS_all); }
    {
        // Step 1: execute action `FadeOutLeds(LEDS_all);`
        FadeOutLeds(LEDS_all);
    } // end of behavior for State_StandBy
}

static void STATE_STANDBY_exit(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_POWERON;
}


////////////////////////////////////////////////////////////////////////////////
// event handlers for state STATE_RINSING
////////////////////////////////////////////////////////////////////////////////

static void STATE_RINSING_enter(SMSodaStreamPure* sm)
{
    sm->state_id = SMSodaStreamPure_StateId_STATE_RINSING;
    
    // State_Rinsing behavior
    // uml: enter / { ButtonsFunction(false); }
    {
        // Step 1: execute action `ButtonsFunction(false);`
        ButtonsFunction(false);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { FadeOutLeds(LEDS_AllCarbonation); }
    {
        // Step 1: execute action `FadeOutLeds(LEDS_AllCarbonation);`
        FadeOutLeds(LEDS_AllCarbonation);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartRinsingLedSequence(); }
    {
        // Step 1: execute action `StartRinsingLedSequence();`
        StartRinsingLedSequence();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { pumpStopsOnSensor = true; }
    {
        // Step 1: execute action `pumpStopsOnSensor = true;`
        sm->vars.pumpStopsOnSensor = true;
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { SolenoidPumpUVPower(1); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(1);`
        SolenoidPumpUVPower(1);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartWaterPump(); }
    {
        // Step 1: execute action `StartWaterPump();`
        StartWaterPump();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { ResetFilterLifetimeTimer(); }
    {
        // Step 1: execute action `ResetFilterLifetimeTimer();`
        ResetFilterLifetimeTimer();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartWaterPumpingTimer(); }
    {
        // Step 1: execute action `StartWaterPumpingTimer();`
        StartWaterPumpingTimer();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: enter / { StartUVLEd(); }
    {
        // Step 1: execute action `StartUVLEd();`
        StartUVLEd();
    } // end of behavior for State_Rinsing
}

static void STATE_RINSING_exit(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: exit / { SolenoidPumpUVPower(0); }
    {
        // Step 1: execute action `SolenoidPumpUVPower(0);`
        SolenoidPumpUVPower(0);
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: exit / { StopWaterPump(); }
    {
        // Step 1: execute action `StopWaterPump();`
        StopWaterPump();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: exit / { StopRinsingLedSequence(); }
    {
        // Step 1: execute action `StopRinsingLedSequence();`
        StopRinsingLedSequence();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: exit / { WaterLedOrangeToBlue(); }
    {
        // Step 1: execute action `WaterLedOrangeToBlue();`
        WaterLedOrangeToBlue();
    } // end of behavior for State_Rinsing
    
    // State_Rinsing behavior
    // uml: exit / { StopUVLed(); }
    {
        // Step 1: execute action `StopUVLed();`
        StopUVLed();
    } // end of behavior for State_Rinsing
    
    sm->state_id = SMSodaStreamPure_StateId_STATE_AUTOMATICMODE;
}

static void STATE_RINSING_event_anykeypress(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: Event_AnyKeyPress TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_RINSING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Rinsing
    
    // No ancestor handles this event.
}

static void STATE_RINSING_event_bottlefullsensor(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: Event_BottleFullSensor TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_RINSING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Rinsing
    
    // No ancestor handles this event.
}

static void STATE_RINSING_event_waterpumpingtimeout(SMSodaStreamPure* sm)
{
    // State_Rinsing behavior
    // uml: Event_WaterPumpingTimeout TransitionTo(State_Ready)
    {
        // Step 1: Exit states until we reach `State_AutomaticMode` state (Least Common Ancestor for transition).
        STATE_RINSING_exit(sm);
        
        // Step 2: Transition action: ``.
        
        // Step 3: Enter/move towards transition target `State_Ready`.
        STATE_POWERON_enter(sm);
        STATE_READY_enter(sm);
        
        // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
        return;
    } // end of behavior for State_Rinsing
    
    // No ancestor handles this event.
}
