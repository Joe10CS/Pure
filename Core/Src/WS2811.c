// WS2811.c
#include "main.h"
// WS2811.c  —  STM32G030 TIM1_CH4 (PA11) + TIM1_UP DMA driver @ 64 MHz
// Generates the WS2811 bitstream: 1.25us/bit, duty‑encoded 0/1, GRB, MSB‑first.
// Key fix: race‑proof start sequence (clear UIF, start PWM, then enable UDE) to avoid a long first bit.

#include "WS2811.h"
#include <string.h>

// ---- External HAL handles generated by CubeMX ----
extern TIM_HandleTypeDef  htim1;          // TIM1 (PWM CH4 on PA11)
extern DMA_HandleTypeDef  hdma_tim1_up;   // DMA request: TIM1_UP

// ---- Timing constants for 64 MHz ----
// 64 MHz → 15.625 ns/tick → 80 ticks = 1.25 us bit time
#define WS_TICKS_PER_BIT   80
#define WS_TIM_ARR         (WS_TICKS_PER_BIT - 1)      // 79

// In‑spec pulse widths (centered in datasheet windows):
// 0‑bit: T0H ≈ 0.3125 us (20 ticks), T0L ≈ 0.9375 us
// 1‑bit: T1H ≈ 0.8594 us (55 ticks), T1L ≈ 0.3906 us
#define WS_CCR_0           20
#define WS_CCR_1           55

// ---- Internal state ----
static volatile bool     s_ws_busy    = false;          // true while frame active
static uint16_t          s_bits_total = 0;              // total bits in this frame
static uint16_t          s_expected_tc = 0;             // DMA transfers after the first preloaded bit

// One halfword per WS bit (max full chain = NUMBER_OF_LEDS bytes → ×8 bits)
static uint16_t          s_ccr_stream[24 * NUMBER_OF_LEDS];

// ---- Forward decls ----
static inline uint8_t pct_to_byte(uint8_t p);
static void encode_first_n_channels_raw(const uint8_t *raw_grb,     uint16_t channels);
static void encode_first_n_channels_percent(const uint8_t *percent, uint16_t channels);
static void ws_start_frame_common(void);

// DMA callbacks (G0 HAL uses registered function pointers)
static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma);
static void WS_TIM1_DMA_Error   (DMA_HandleTypeDef *hdma);

// ============================================================================
// Public API
// ============================================================================

void WS_InitLeds(void)
{
    // Make sure timer period is correct for 1.25us slots
    __HAL_TIM_SET_AUTORELOAD(&htim1, WS_TIM_ARR);

    // Very important: OC preload on CH4 must be DISABLED so CCR writes take effect next cycle
    __HAL_TIM_DISABLE_OCxPRELOAD(&htim1, TIM_CHANNEL_4);

    // Idle low when not sending
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

    // Register DMA callbacks so HAL_DMA_IRQHandler() can call us
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_CPLT_CB_ID,  WS_TIM1_DMA_Complete);
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_ERROR_CB_ID, WS_TIM1_DMA_Error);

    s_ws_busy = false;
}

bool WS_IsBusy(void) { return s_ws_busy; }

HAL_StatusTypeDef WS_SetLeds(const uint8_t *leds_percent, uint16_t num_to_set_channels)
{
    if (s_ws_busy)                        return HAL_BUSY;
    if (!leds_percent)                    return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    // MUST send whole devices (3 channels = 24 bits) to preserve alignment downstream.
    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    // Build CCR stream for exactly N channels (bytes), MSB‑first, GRB order.
    encode_first_n_channels_percent(leds_percent, num_to_set_channels);

    // We transmit exactly N*8 bits as requested.
    s_bits_total  = (uint16_t)(8u * num_to_set_channels);
    s_expected_tc = (s_bits_total > 0u) ? (s_bits_total - 1u) : 0u;  // after the first preloaded bit

    ws_start_frame_common();
    return HAL_OK;
}

HAL_StatusTypeDef WS_SetLedsRaw(const uint8_t *grb_bytes, uint16_t num_to_set_channels)
{
    if (s_ws_busy)                        return HAL_BUSY;
    if (!grb_bytes)                       return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    encode_first_n_channels_raw(grb_bytes, num_to_set_channels);

    s_bits_total  = (uint16_t)(8u * num_to_set_channels);
    s_expected_tc = (s_bits_total > 0u) ? (s_bits_total - 1u) : 0u;

    ws_start_frame_common();
    return HAL_OK;
}

// ============================================================================
// Start sequence (race‑proof): fixes the "long first bit" by ordering steps.
// ============================================================================

static void ws_start_frame_common(void)
{
    // ---- CLEAN START STATE ----
    // Stop any previous activity so line idles LOW and no DMA requests are pending.
    __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

    // Clear any stale DMA flags on our channel
    __HAL_DMA_CLEAR_FLAG(&hdma_tim1_up, DMA_FLAG_TC4 | DMA_FLAG_HT4 | DMA_FLAG_TE4 | DMA_FLAG_GI4);

    // **CRITICAL**: clear the TIM1 UPDATE flag (UIF) so enabling UDE won't trigger immediately.
    __HAL_TIM_CLEAR_FLAG(&htim1, TIM_FLAG_UPDATE);

    // ---- PRELOAD FIRST BIT + RESET COUNTER ----
    TIM1->CCR4 = s_ccr_stream[0];           // Period #0 uses this CCR value
    __HAL_TIM_SET_AUTORELOAD(&htim1, WS_TIM_ARR);
    __HAL_TIM_SET_COUNTER(&htim1, 0);

    // ---- ARM DMA FOR REMAINING BITS (doesn't transfer until UDE + update) ----
    if (s_expected_tc > 0u) {
        (void)HAL_DMA_Start_IT(&hdma_tim1_up,
                               (uint32_t)&s_ccr_stream[1],     // source: remaining CCR entries
                               (uint32_t)&TIM1->CCR4,          // destination: CCR4
                               s_expected_tc);                 // transfers after first
    }

    // ---- START PWM (period #0 begins now, using CCR[0]) ----
    (void)HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);

    // ---- FINALIZE: ensure UIF is still clear, then enable UDE so the FIRST DMA
    //               write happens exactly at the END of period #0 (no mid‑period write).
    __HAL_TIM_CLEAR_FLAG(&htim1, TIM_FLAG_UPDATE);
    if (s_expected_tc > 0u) {
        __HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_UPDATE);
    }

    s_ws_busy = true;
}

// ============================================================================
// DMA callbacks — called by HAL from DMA1_Ch4_5_DMAMUX1_OVR_IRQHandler()
// ============================================================================

static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);   // PA11 idles LOW; >280 µs latch met by your 10 ms cadence
        s_ws_busy = false;
    }
}

static void WS_TIM1_DMA_Error(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);
        s_ws_busy = false;
        // Optional: inspect HAL_DMA_GetError(hdma) for diagnostics.
    }
}

// ============================================================================
// Encoding helpers
// ============================================================================

// Map 0..100% to 0..255 (rounded)
static inline uint8_t pct_to_byte(uint8_t p)
{
    if (p > 100) p = 100;
    return (uint8_t)((p * 255u + 50u) / 100u);
}

// Encode exactly N channels from GRB array (0..255), MSB‑first per byte
static void encode_first_n_channels_raw(const uint8_t *raw_grb, uint16_t channels)
{
    uint16_t *p = s_ccr_stream;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = raw_grb[i];
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
}

// Encode exactly N channels from GRB array (0..100%), MSB‑first per byte
static void encode_first_n_channels_percent(const uint8_t *percent, uint16_t channels)
{
    uint16_t *p = s_ccr_stream;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = pct_to_byte(percent[i]);
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
}
