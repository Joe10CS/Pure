// WS2811.c
#include "main.h"
// WS2811.c — STM32G030 TIM1_CH4 (PA11) + TIM1_CC4 DMA @ 64 MHz
// Robust, race‑free driver for WS2811/WS2812 bitstream using:
//   • 1.25 us/bit (ARR=79 @ 64 MHz, PSC=0), PWM mode 1 on TIM1_CH4
//   • Duty encodes 0/1: CCR0=20 (~0.3125 us), CCR1=55 (~0.8594 us)  → both in spec
//   • DMA triggers on CC4 (falling edge); DMA writes NEXT CCR into the preload register
//     which then latches at the next update (start of next bit).
//
// IMPORTANT: This file *forces* your DMA request to TIM1_CC4 at runtime
// even if CubeMX left it at TIM1_UP, so your project works immediately.
// (You should still update CubeMX later to keep Msp code consistent.)

#include "WS2811.h"
#include <string.h>

// --- HAL handles generated by CubeMX (your names) ---
extern TIM_HandleTypeDef  htim1;           // TIM1 (PWM CH4 on PA11)
// NOTE: Your handle is named hdma_tim1_up. We will reconfigure it to CC4 at runtime.
extern DMA_HandleTypeDef  hdma_tim1_up;

// If the LL headers are available, include them so we can force DMAMUX cleanly.
// (Not strictly required; we also provide a pure-HAL path below.)
#if __has_include("stm32g0xx_ll_dma.h")
  #include "stm32g0xx_ll_dma.h"
  #include "stm32g0xx_ll_bus.h"
  #define WS_HAVE_LL 1
#else
  #define WS_HAVE_LL 0
#endif

// ---- Timing (64 MHz -> 15.625 ns/tick) ----
#define WS_TICKS_PER_BIT   80                    // 80 ticks = 1.25 us
#define WS_TIM_ARR         (WS_TICKS_PER_BIT - 1) // 79

// In-spec pulse widths with margin (datasheet):
// 0: T0H ≈ 0.3125 us (20 ticks), T0L ≈ 0.9375 us
// 1: T1H ≈ 0.8594 us (55 ticks), T1L ≈ 0.3906 us
#define WS_CCR_0           20
#define WS_CCR_1           55

// ---- Driver state ----
static volatile bool s_ws_busy     = false;
static uint16_t      s_bits_total  = 0;     // total bits this frame
static uint16_t      s_expected_tc = 0;     // DMA transfers after the first preloaded bit

// One halfword per WS bit (max = NUMBER_OF_LEDS bytes * 8 bits)
static uint16_t s_ccr_stream[24 * NUMBER_OF_LEDS];

// ---- Forward decls ----
static inline uint8_t pct_to_byte(uint8_t p);
static void encode_first_n_channels_raw    (const uint8_t *raw_grb,     uint16_t channels);
static void encode_first_n_channels_percent(const uint8_t *percent_grb, uint16_t channels);
static HAL_StatusTypeDef ws_force_cc4_request(void);
static void ws_start_frame_cc4(void);
static inline void ws_delay_us_min(uint32_t us);

// DMA callbacks (G0 HAL uses registered function pointers)
static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma);
static void WS_TIM1_DMA_Error   (DMA_HandleTypeDef *hdma);

// ============================================================================
// Public API
// ============================================================================

void WS_InitLeds(void)
{
    // Ensure 1.25 us bit period
    __HAL_TIM_SET_AUTORELOAD(&htim1, WS_TIM_ARR);

    // REQUIRE: OC preload on CH4 so CC4-DMA writes go into preload (latched next update)
    __HAL_TIM_ENABLE_OCxPRELOAD(&htim1, TIM_CHANNEL_4);

    // Idle low when not sending
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

    // Make sure our DMA request really is TIM1_CC4 (not TIM1_UP).
    (void)ws_force_cc4_request();

    // Register DMA callbacks so HAL_DMA_IRQHandler() calls us
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_CPLT_CB_ID,  WS_TIM1_DMA_Complete);
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_ERROR_CB_ID, WS_TIM1_DMA_Error);

    s_ws_busy = false;
}

bool WS_IsBusy(void) { return s_ws_busy; }

HAL_StatusTypeDef WS_SetLeds(const uint8_t *leds_percent, uint16_t num_to_set_channels)
{
    if (s_ws_busy)                        return HAL_BUSY;
    if (!leds_percent)                    return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    // MUST send whole WS2811 devices (3 channels) to preserve downstream alignment
    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    encode_first_n_channels_percent(leds_percent, num_to_set_channels);

    // We transmit exactly num_to_set_channels * 8 bits (your requirement)
    s_bits_total  = (uint16_t)(8u * num_to_set_channels);
    s_expected_tc = (s_bits_total > 0u) ? (s_bits_total - 1u) : 0u;  // after first preloaded bit

    ws_start_frame_cc4();
    return HAL_OK;
}

HAL_StatusTypeDef WS_SetLedsRaw(const uint8_t *grb_bytes, uint16_t num_to_set_channels)
{
    if (s_ws_busy)                        return HAL_BUSY;
    if (!grb_bytes)                       return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    encode_first_n_channels_raw(grb_bytes, num_to_set_channels);

    s_bits_total  = (uint16_t)(8u * num_to_set_channels);
    s_expected_tc = (s_bits_total > 0u) ? (s_bits_total - 1u) : 0u;

    ws_start_frame_cc4();
    return HAL_OK;
}

// ============================================================================
// Force DMAMUX request = TIM1_CC4 for hdma_tim1_up (runtime safety net)
// ============================================================================

static HAL_StatusTypeDef ws_force_cc4_request(void)
{
#if WS_HAVE_LL
    // Use LL to set the DMAMUX request to TIM1_CC4 based on the channel instance
    DMA_Channel_TypeDef *ch = hdma_tim1_up.Instance;
    if (ch == DMA1_Channel1) LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_1, LL_DMAMUX_REQ_TIM1_CH4);
    else if (ch == DMA1_Channel2) LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_2, LL_DMAMUX_REQ_TIM1_CH4);
    else if (ch == DMA1_Channel3) LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_3, LL_DMAMUX_REQ_TIM1_CH4);
    else if (ch == DMA1_Channel4) LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_4, LL_DMAMUX_REQ_TIM1_CH4);
    else if (ch == DMA1_Channel5) LL_DMA_SetPeriphRequest(DMA1, LL_DMA_CHANNEL_5, LL_DMAMUX_REQ_TIM1_CH4);
    // (If you’re on a different DMA instance, add cases accordingly.)
    return HAL_OK;
#else
    // Pure HAL fallback: re-init the handle with CC4 request if needed.
    if (hdma_tim1_up.Init.Request != DMA_REQUEST_TIM1_CH4) {
        HAL_DMA_DeInit(&hdma_tim1_up);
        hdma_tim1_up.Init.Request             = DMA_REQUEST_TIM1_CH4;   // <-- key line
        hdma_tim1_up.Init.Direction           = DMA_MEMORY_TO_PERIPH;
        hdma_tim1_up.Init.PeriphInc           = DMA_PINC_DISABLE;
        hdma_tim1_up.Init.MemInc              = DMA_MINC_ENABLE;
        hdma_tim1_up.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
        hdma_tim1_up.Init.MemDataAlignment    = DMA_MDATAALIGN_HALFWORD;
        hdma_tim1_up.Init.Mode                = DMA_NORMAL;
        hdma_tim1_up.Init.Priority            = DMA_PRIORITY_HIGH;
        if (HAL_DMA_Init(&hdma_tim1_up) != HAL_OK) return HAL_ERROR;

        // Link this DMA handle to TIM1 CC4 (not update)
        __HAL_LINKDMA(&htim1, hdma[TIM_DMA_ID_CC4], hdma_tim1_up);
    }
    return HAL_OK;
#endif
}

// ============================================================================
// Start sequence — CC4-triggered DMA + OC-preload (race‑free first bit)
// ============================================================================

static void ws_start_frame_cc4(void)
{
    // 0) Clean idle
    __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_CC4);
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

    // 1) Clear DMA flags on our channel
    __HAL_DMA_CLEAR_FLAG(&hdma_tim1_up, DMA_FLAG_TC4 | DMA_FLAG_HT4 | DMA_FLAG_TE4 | DMA_FLAG_GI4);

    // 2) Preload FIRST bit and latch it active via explicit update
    TIM1->CCR4 = s_ccr_stream[0];
    __HAL_TIM_SET_AUTORELOAD(&htim1, WS_TIM_ARR);
    __HAL_TIM_SET_COUNTER(&htim1, 0);
    HAL_TIM_GenerateEvent(&htim1, TIM_EVENTSOURCE_UPDATE);   // UG -> preload -> active (CCR now "live")

    // 3) Arm DMA for the REMAINING bits (they write CCR4 preload on each CC4)
    if (s_expected_tc > 0u) {
        (void)HAL_DMA_Start_IT(&hdma_tim1_up,
                               (uint32_t)&s_ccr_stream[1],      // source: remaining CCR entries
                               (uint32_t)&TIM1->CCR4,           // dest: CCR4 (preload)
                               s_expected_tc);
    }

    // 4) Clear CC4 flag, enable CC4 DMA requests
    __HAL_TIM_CLEAR_FLAG(&htim1, TIM_FLAG_CC4);
    if (s_expected_tc > 0u) {
        __HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_CC4);
    }

    // 5) (Optional but robust) Prime one CC4 DMA via software so CCR[1] is staged
    //    even before we start the counter. This eliminates any "late first CC4" worry.
    if (s_expected_tc > 0u) {
        HAL_TIM_GenerateEvent(&htim1, TIM_EVENTSOURCE_CC4);   // SW CC4G -> one DMA write into preload
    }

    // 6) Start PWM — period #0 begins now using CCR[0]
    (void)HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);

    s_ws_busy = true;
}

// ============================================================================
// DMA callbacks
// ============================================================================

static inline void ws_delay_us_min(uint32_t us)
{
    // crude cycle delay (OK for ~microsecond waits)
    uint32_t cycles = (SystemCoreClock / 1000000U) * us;
    while (cycles--) { __NOP(); }
}

static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        // All CCRs have been queued; the last one becomes active at the next update.
        // Wait ~1.5 us so the final bit fully finishes, then stop PWM.
        ws_delay_us_min(2);  // ~2 us >> 1.25 us period

        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_CC4);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);  // line idles LOW; your 10 ms cadence >> 280 us latch
        s_ws_busy = false;
    }
}

static void WS_TIM1_DMA_Error(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_CC4);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);
        s_ws_busy = false;
        // Optional: inspect HAL_DMA_GetError(hdma)
    }
}

// ============================================================================
// Encoding helpers — GRB order, MSB‑first per byte
// ============================================================================

static inline uint8_t pct_to_byte(uint8_t p)
{
    if (p > 100) p = 100;
    return (uint8_t)((p * 255u + 50u) / 100u);
}

static void encode_first_n_channels_raw(const uint8_t *raw_grb, uint16_t channels)
{
    uint16_t *p = s_ccr_stream;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = raw_grb[i];              // 0..255
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
}

static void encode_first_n_channels_percent(const uint8_t *percent_grb, uint16_t channels)
{
    uint16_t *p = s_ccr_stream;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = pct_to_byte(percent_grb[i]); // 0..100% -> 0..255
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
}
