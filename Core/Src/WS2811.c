// WS2811.c
#include "main.h"
// WS2811.c — STM32G030 TIM1_CH4 (PA11) + TIM1_UPDATE DMA @ 64 MHz
// One DMA transfer includes a reset/latch low preamble (>280 us) *and* the data bits.
// Timeline:
//   [K× 1.25us slots at CCR4=0  → continuous LOW ≥ 280us]  +  [encoded GRB bits @ 1.25us/bit]
//
// Why this fixes the first-bit glitch:
//   The stream starts with many fully-low periods (CCR=0 → no rising edges). Any start-up race
//   can only affect this low preamble, which is harmless. When the stream reaches the first
//   actual data CCR (20 or 55), the timer/DMA pipeline is already in steady state, so the
//   first *real* bit is correct.
//
// CubeMX requirements (same as you have already):
//   • TIM1 CH4 = PWM mode 1 on PA11, PSC=0, ARR=79 (1.25us)
//   • TIM1 CH4 Output Compare PRELOAD = **DISABLED** (we want CCR writes to take effect next cycle)
//   • DMA request = TIM1_UP (Update), Mem->Periph, Half-word, MemInc=EN, Normal, Priority=High
//   • NVIC: DMA IRQ calls HAL_DMA_IRQHandler(&hdma_tim1_up); TIM1 BRK_UP IRQ calls HAL_TIM_IRQHandler(&htim1);
//
// Public API (see WS2811.h):
//   void WS_InitLeds(void);
//   HAL_StatusTypeDef WS_SetLeds(const uint8_t *leds_percent, uint16_t num_to_set_channels);
//   HAL_StatusTypeDef WS_SetLedsRaw(const uint8_t *grb_bytes, uint16_t num_to_set_channels);
//   bool WS_IsBusy(void);

#include "WS2811.h"
#include <string.h>

// ---- External HAL handles generated by CubeMX ----
extern TIM_HandleTypeDef  htim1;           // TIM1 (PWM CH4 on PA11)
extern DMA_HandleTypeDef  hdma_tim1_up;    // TIM1 Update DMA (Mem->Periph)

// ---- Timing (64 MHz -> 15.625 ns/tick) ----
#define WS_TICKS_PER_BIT      80                 // 80 ticks = 1.25 us
#define WS_TIM_ARR            (WS_TICKS_PER_BIT - 1) // 79

// Bit pulse widths (in ticks), centered well inside spec:
#define WS_CCR_0              20                 // '0' high  ~0.3125 us, low ~0.9375 us
#define WS_CCR_1              55                 // '1' high  ~0.8594 us, low ~0.3906 us

// Reset/latch gap: a short, edge-free preamble to settle TIM+DMA
#define WS_PREAMBLE_US      12U  // pick 10–20 us; 12 us shown here
#define WS_PREAMBLE_SLOTS   ((uint16_t)(((WS_PREAMBLE_US)*1000U + 1249U) / 1250U))  // ceil(us / 1.25us)

// tiny low tail so any late stop emits LOW, not extra edges
#define WS_TAIL_SLOTS        4U   // ~5 us tail (4 × 1.25 us)

// ---- Driver state ----
volatile bool gLedsWSBusyTxing = false;
// Track how many 1.25 us periods we plan to emit in this frame
volatile uint16_t gLedsCountTxCountDown = 0;

// One halfword per PWM period we emit.
// Enough for reset preamble + all bits of the largest frame you send.
// NUMBER_OF_LEDS = devices * 3 (channels); bits = 8*NUMBER_OF_LEDS.
// Add WS_RESET_SLOTS of preamble.
static uint16_t s_ccr_stream[WS_PREAMBLE_SLOTS + 8 * NUMBER_OF_LEDS];

// Forward decls
static inline uint8_t pct_to_byte(uint8_t p);
static void encode_preamble(uint16_t **p_ccr);
static void encode_first_n_channels_raw    (uint16_t **p_ccr, const uint8_t *raw_grb,     uint16_t channels);
static void encode_first_n_channels_percent(uint16_t **p_ccr, const uint8_t *percent_grb, uint16_t channels);

// DMA callbacks (G0 HAL uses registered function pointers)
static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma);
static void WS_TIM1_DMA_Error   (DMA_HandleTypeDef *hdma);

// ============================================================================
// Public API
// ============================================================================

void WS_InitLeds(void)
{
    // Ensure 1.25 us bit period
    __HAL_TIM_SET_AUTORELOAD(&htim1, WS_TIM_ARR);

    // OC preload on CH4 must be DISABLED for Update-DMA streaming (immediate use next cycle)
    __HAL_TIM_DISABLE_OCxPRELOAD(&htim1, TIM_CHANNEL_4);

    // Idle low when not sending
    HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

    // Register DMA callbacks so HAL_DMA_IRQHandler() calls us
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_CPLT_CB_ID,  WS_TIM1_DMA_Complete);
    HAL_DMA_RegisterCallback(&hdma_tim1_up, HAL_DMA_XFER_ERROR_CB_ID, WS_TIM1_DMA_Error);

    gLedsWSBusyTxing = false;
}

bool WS_IsBusy(void) { return gLedsWSBusyTxing; }

HAL_StatusTypeDef WS_SetLeds(const uint8_t *leds_percent, uint16_t num_to_set_channels)
{
    if (gLedsWSBusyTxing)                        return HAL_BUSY;
    if (!leds_percent)                    return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    // MUST send whole WS2811 devices (3 channels) to preserve downstream alignment
    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    // Build [reset preamble + data] into s_ccr_stream
    uint16_t *w = s_ccr_stream;
    encode_preamble(&w);
    encode_first_n_channels_percent(&w, leds_percent, num_to_set_channels);
    uint16_t total_entries = (uint16_t)(w - s_ccr_stream);

    // ---- race-proof start for Update-DMA stream ----
    // Period #0 uses s_ccr_stream[0] (which is 0, i.e., low). Any start-up race is harmless here.
    TIM1->CCR4 = s_ccr_stream[0];

    // Arm DMA for the rest of the entries
    if (total_entries > 1u) {
        if (HAL_DMA_Start_IT(&hdma_tim1_up,
                             (uint32_t)&s_ccr_stream[1],
                             (uint32_t)&TIM1->CCR4,
                             (uint16_t)(total_entries - 1u)) != HAL_OK) {
            return HAL_ERROR;
        }
        __HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_UPDATE);
    }

    // Reset counters and start PWM
    __HAL_TIM_SET_COUNTER(&htim1, 0);
    if (HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4) != HAL_OK) {
        if (total_entries > 1u) {
            __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
            HAL_DMA_Abort(&hdma_tim1_up);
        }
        return HAL_ERROR;
    }

    gLedsWSBusyTxing = true;
    return HAL_OK;
}

HAL_StatusTypeDef WS_SetLedsRaw(const uint8_t *grb_bytes, uint16_t num_to_set_channels)
{
    if (gLedsWSBusyTxing)                        return HAL_BUSY;
    if (!grb_bytes)                       return HAL_ERROR;
    if (num_to_set_channels == 0)         return HAL_ERROR;
    if (num_to_set_channels > NUMBER_OF_LEDS)
        num_to_set_channels = NUMBER_OF_LEDS;

    if ((num_to_set_channels % 3u) != 0u) return HAL_ERROR;

    // Build [reset preamble + data] into s_ccr_stream
    uint16_t *w = s_ccr_stream;
    encode_preamble(&w);
    encode_first_n_channels_raw(&w, grb_bytes, num_to_set_channels);
    // Append LOW tail (WS_TAIL_SLOTS periods of CCR=0)
    for (uint16_t i = 0; i < WS_TAIL_SLOTS; ++i) { *w++ = 0; }
    uint16_t total_entries = (uint16_t)(w - s_ccr_stream);
    uint16_t max_entries   = (uint16_t)(sizeof(s_ccr_stream) / sizeof(s_ccr_stream[0]));
    if (total_entries == 0 || total_entries > max_entries) return HAL_ERROR;
    // This is how many 1.25 us periods we expect to emit in this frame
    gLedsCountTxCountDown = total_entries;

    // Start as above
    TIM1->CCR4 = s_ccr_stream[0];
    if (total_entries > 1u) {
        if (HAL_DMA_Start_IT(&hdma_tim1_up,
                             (uint32_t)&s_ccr_stream[1],
                             (uint32_t)&TIM1->CCR4,
                             (uint16_t)(total_entries - 1u)) != HAL_OK) {
            return HAL_ERROR;
        }
        __HAL_TIM_ENABLE_DMA(&htim1, TIM_DMA_UPDATE);
    }
    __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_CC4);   // ensure CC4 DMA is off
    __HAL_TIM_ENABLE_IT(&htim1, TIM_IT_UPDATE);   // guard

    __HAL_TIM_SET_COUNTER(&htim1, 0);
    if (HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4) != HAL_OK) {
        if (total_entries > 1u) {
            __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
            HAL_DMA_Abort(&hdma_tim1_up);
        }
        __HAL_TIM_DISABLE_IT(&htim1, TIM_IT_UPDATE);
        return HAL_ERROR;
    }

    gLedsWSBusyTxing = true;
    return HAL_OK;
}

// ============================================================================
// DMA callbacks — stop PWM at end; line idles LOW (reset for next frame)
// ============================================================================
// Called by HAL when TIM1 update fires (we’ll hook it through HAL_TIM_PeriodElapsedCallback)
void WS_Tim1UpdateGuard(void)
{
    if (gLedsWSBusyTxing && gLedsCountTxCountDown) {
        if (--gLedsCountTxCountDown == 0) {
            // We’ve emitted exactly the requested number of 1.25 us periods.
            __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
            __HAL_TIM_DISABLE_IT(&htim1, TIM_IT_UPDATE);
            HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);
            gLedsWSBusyTxing = false;
        }
    }
}

static void WS_TIM1_DMA_Complete(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);  // line stays LOW; reset gap satisfied until next call
        gLedsWSBusyTxing = false;
    }
}

static void WS_TIM1_DMA_Error(DMA_HandleTypeDef *hdma)
{
    if (hdma == &hdma_tim1_up) {
        __HAL_TIM_DISABLE_DMA(&htim1, TIM_DMA_UPDATE);
        HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);
        gLedsWSBusyTxing = false;
        // optional: inspect HAL_DMA_GetError(hdma)
    }
}

// ============================================================================
// Encoding helpers — GRB order, MSB‑first per byte
// ============================================================================

static inline uint8_t pct_to_byte(uint8_t p)
{
    if (p > 100) p = 100;
    return (uint8_t)((p * 255u + 50u) / 100u);
}

// Write K entries of CCR=0 → continuous LOW few us
static void encode_preamble(uint16_t **p_ccr) {
    uint16_t *p = *p_ccr;
    for (uint16_t i = 0; i < WS_PREAMBLE_SLOTS; ++i) {
        *p++ = 0;  // CCR=0 → line stays LOW, no rising edge, no bit consumed
    }
    *p_ccr = p;
}

static void encode_first_n_channels_raw(uint16_t **p_ccr, const uint8_t *raw_grb, uint16_t channels)
{
    uint16_t *p = *p_ccr;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = raw_grb[i];          // 0..255
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
    *p_ccr = p;
}

static void encode_first_n_channels_percent(uint16_t **p_ccr, const uint8_t *percent_grb, uint16_t channels)
{
    uint16_t *p = *p_ccr;
    for (uint16_t i = 0; i < channels; ++i) {
        uint8_t v = pct_to_byte(percent_grb[i]); // 0..100% -> 0..255
        for (int b = 7; b >= 0; --b) {
            *p++ = ((v >> b) & 1) ? WS_CCR_1 : WS_CCR_0;
        }
    }
    *p_ccr = p;
}
